<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SceneCard Writer v6.19 (Fixed Pitch - Final Spacing)</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root { 
            --bg: #f4f4f9; --sidebar: #2c3e50; --text: #333; 
            --accent: #3498db; --border: #ddd; --card-bg: #fff;
            --input-bg: #fff; --sb-tool: #34495e;
            --action-bg: #f0f8ff; /* Light blue for action rows */
        }
        
        /* Dark Mode Overrides */
        body.dark-mode {
            --bg: #1e1e1e; --sidebar: #151515; --text: #ecf0f1; 
            --border: #444; --card-bg: #2c2c2c; 
            --input-bg: #333; --sb-tool: #252525;
            --action-bg: #3b3b4d; /* Darker blue/gray for action rows */
        }

        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; display: flex; height: 100vh; background: var(--bg); color: var(--text); overflow: hidden; transition: background 0.3s; }
        
        /* --- LAYOUT & UI (Standard View) --- */
        #sidebar { width: 300px; background: var(--sidebar); color: white; display: flex; flex-direction: column; border-right: 1px solid #1a252f; flex-shrink: 0; transition: width 0.3s; }
        #main { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; position: relative; }
        
        /* --- SIDEBAR COMPONENTS --- */
        .brand { padding: 15px; font-size: 1.1rem; font-weight: bold; background: rgba(0,0,0,0.2); display: flex; justify-content: space-between; align-items: center; }
        .theme-toggle { cursor: pointer; background: none; border: none; font-size: 1.2rem; }

        .tools { padding: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .tool-btn { background: var(--sb-tool); color: white; border: 1px solid #46637f; padding: 6px; cursor: pointer; font-size: 0.75rem; border-radius: 4px; }
        .tool-btn:hover { background: #3e5871; }

        #search-input {
            width: 90%; margin: 10px auto; padding: 8px 10px;
            background: var(--sb-tool); border: 1px solid #46637f;
            color: white; border-radius: 4px; display: block; box-sizing: border-box;
        }

        .add-btn { padding: 15px; background: #27ae60; color: white; border: none; cursor: pointer; font-weight: bold; border-bottom: 1px solid #1e8449; }
        .add-btn:hover { background: #2ecc71; }

        .card-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
        .card-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); cursor: pointer; font-size: 0.9rem; border-left: 6px solid #555; }
        .card-item.active { background: rgba(255,255,255,0.1); border-right: 4px solid var(--accent); }
        
        /* Color Coding */
        .card-item.scene-int, .board-card.scene-int { border-left-color: #3498db; }
        .card-item.scene-ext, .board-card.scene-ext { border-left-color: #2ecc71; }
        .card-item.scene-montage, .board-card.scene-montage { border-left-color: #9b59b6; } 

        /* --- EDITOR VIEW --- */
        .editor-card { background: var(--card-bg); padding: 30px; border-radius: 8px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        
        /* Fixed UI Break: Clear fix for the floating time estimate */
        .scene-header-group {
            display: flex; 
            flex-direction: column;
            overflow: auto; 
        }
        #screen-time-estimate {
            order: 1; 
            float: right;
            align-self: flex-end; 
        }
        #scene-number-display {
            order: 2; 
            align-self: flex-start; 
        }
        
        label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.75rem; text-transform: uppercase; color: #7f8c8d; }
        input, textarea { width: 100%; padding: 10px; border: 1px solid var(--border); background: var(--input-bg); color: var(--text); border-radius: 4px; box-sizing: border-box; }
        
        /* Time Estimate Styling */
        #screen-time-estimate {
            font-size: 1.1em; 
            font-weight: bold; 
            color: var(--accent);
            padding: 5px 0 15px 0;
        }

        /* SEQUENCE TABLE */
        table.sequence-table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        table.sequence-table th { text-align: left; background: rgba(0,0,0,0.05); padding: 8px; font-size: 0.75rem; color: #7f8c8d; }
        
        table.sequence-table td { padding: 0; }
        
        .row-character { border-bottom: 1px solid var(--border); }
        .row-action { background: var(--action-bg); border-bottom: 1px solid var(--border); }

        /* Custom cell for Dialogue context/contd controls */
        .col-dialog-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            padding: 8px;
            gap: 5px;
            font-size: 0.8em;
            height: 100%;
        }
        .col-dialog-controls select {
            padding: 5px;
            border: 1px solid var(--border);
            background: var(--input-bg);
        }
        .contd-checkbox {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .sequence-input { border: none; background: transparent; padding: 8px; border-bottom: 1px solid transparent; width: 100%; box-sizing: border-box; }
        .sequence-input:focus { border-bottom: 1px solid var(--accent); outline: none; }
        
        /* Dialogue row specific field grouping */
        .dialog-character-group {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Character/Parenthetical cell */
        .dialog-character-group input { 
            border-bottom: 1px solid var(--border); 
            padding: 8px; 
            box-sizing: border-box;
            background: var(--input-bg);
        }
        .dialog-character-group input:focus {
            border-bottom: 1px solid var(--accent);
        }
        /* Overriding the last border for the parenthetical input */
        .dialog-character-group input:last-child {
            border-bottom: none;
        }

        /* Dialogue/Action Text cell */
        .col-content-dialog textarea { 
            width: 100%; min-height: 80px; resize: vertical; border: none; 
            border-radius: 0; background: transparent; padding: 8px; box-sizing: border-box; 
            font-family: inherit; color: inherit;
        }
        .col-content-dialog textarea:focus { border-bottom: 1px solid var(--accent); outline: none; }
        
        /* Action row specific layout */
        .row-action td { padding: 0; }
        .row-action td:first-child { 
            padding: 8px;
            color: #7f8c8d; 
            font-size: 0.8em; 
            font-style: italic;
        } 
        
        .row-action .action-style-select {
            width: 100%;
            height: 100%;
            border: none;
            padding: 8px;
            background: var(--input-bg);
            border-right: 1px solid var(--border);
            border-left: 1px solid var(--border);
            box-sizing: border-box;
        }

        .row-action .action-content-textarea {
            width: 100%; 
            min-height: 80px; 
            resize: vertical; 
            border: none; 
            border-radius: 0; 
            background: transparent; 
            padding: 8px; 
            box-sizing: border-box; 
            font-family: inherit; 
            color: inherit;
        }

        .col-del { cursor: pointer; color: #e74c3c; text-align: center; }
        
        /* UTILS */
        .hidden { display: none !important; }

        /* VIEW CONTAINER VISIBILITY FIX */
        .view-container { display: none; }
        .view-container.visible { display: block; }

        /* --- SCRIPT VIEW (Fixed Pitch / Fixed Line Height) --- */
        
        #script-view { 
            overflow-y: auto; 
            background: #f0f0f0; 
            padding: 20px;
        }
        
        #script-content { 
            max-width: 8.5in; 
            margin: 0 auto; 
            box-shadow: 0 0 10px rgba(0,0,0,0.2); 
            background: white;
            
            /* Enforce Fixed Pitch for Print Preview */
            font-family: 'Courier Prime', 'Courier New', monospace; 
            font-size: 12pt; 
        }

        /* Page container to apply print margins/breaks */
        .sc-page {
            padding: 1in 1in 1in 1.5in; /* Matches standard print margins */
            box-sizing: border-box;
            height: 11in; /* Standard US Letter Height */
            background: white;
            
            page-break-after: always; 
            position: relative;
        }
        
        .sc-title-page {
            padding: 1in; 
            box-sizing: border-box;
            height: 11in; 
            background: white;
            page-break-after: always;
            color: black;
        }

        /* CRITICAL FIX: Ensure every line element has the exact, necessary line height */
        /* Target all direct children of sc-page (which are the line elements) */
        #script-content > div:not(.sc-title-page) > div {
            white-space: pre; 
            margin: 0; 
            padding: 0;
            text-indent: 0;
            line-height: 1.2em !important; /* Fixed line height is crucial for 55 lines per page */
            color: black;
        }
        
        /* CRITICAL FIX: Spacer element to guarantee vertical line height */
        .sc-spacer {
            height: 1.2em !important; /* Must match the content line-height */
            margin: 0 !important; 
            padding: 0 !important;
            line-height: 1.2em !important; 
            content: "";
            display: block; 
        }


        /* Special Styling for specific line types */
        .sc-header { text-transform: uppercase; font-weight: bold; }
        .sc-transition { text-align: right; }
        .sc-page-number { text-align: right; font-size: 10pt; line-height: 1em; position: absolute; top: 0.75in; right: 1in; }
        .sc-intertitle { text-align: center; font-weight: bold; }
        
        /* --- FINAL PRINT STYLES --- */
        @media print {
            /* 1. CRITICAL: FORCE HIDE ALL UI ELEMENTS */
            body > *:not(#main) {
                display: none !important;
            }

            /* 2. CRITICAL: HIDE SPECIFIC MAIN/VIEW ELEMENTS */
            #sidebar, 
            #editor-view, 
            #storyboard-view,
            #print-button,
            /* Force hide all views except script-view */
            #main > .view-container:not(#script-view),
            #stats-modal,
            #char-modal,
            #metadata-modal {
                display: none !important;
                visibility: hidden !important; 
                opacity: 0 !important; /* Triple redundancy for hiding */
            }
            
            /* 3. MAIN CONTAINER MUST BE DISPLAY: BLOCK */
            #main {
                display: block !important;
                width: 100% !important;
                padding: 0 !important;
                overflow: visible !important;
                position: absolute !important; 
                left: 0 !important;
                top: 0 !important;
                z-index: 9999 !important;
            }

            /* 4. SCRIPT VIEW MUST BE DISPLAY: BLOCK */
            #script-view {
                display: block !important; 
                width: 100% !important;
                height: auto !important;
                padding: 0 !important; 
                margin: 0 !important;
                overflow: visible !important;
                background: white !important;
            }

            /* 5. PAGE CONTAINER - Final Print Formatting */
            .sc-page {
                width: 8.5in; 
                height: 11in; 
                /* REINFORCED MARGINS - MUST BE EXACT */
                padding: 1in 1in 1in 1.5in !important; /* Top, Right, Bottom, Left */
                margin: 0 !important;
                box-sizing: border-box;
                background: white !important;
                page-break-after: always !important; 
            }
            
            .sc-title-page {
                width: 8.5in; 
                height: 11in; 
                padding: 1in !important; 
                margin: 0 !important;
                box-sizing: border-box;
                background: white !important;
                page-break-after: always !important; 
                color: black !important;
            }

            /* 6. PAGE NUMBER OVERRIDE */
            .sc-page-number {
                top: 0.5in !important; 
                right: 1in !important;
            }
        }
    </style>
</head>
<body>

    <datalist id="character-list"></datalist>

    <div id="sidebar">
        <div class="brand">
            <span>üé¨ ScreenCard</span>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Dark Mode">üåì</button>
        </div>
        <div class="tools">
            <button class="tool-btn" onclick="saveJSON()">üíæ Save .JSON</button>
            <button class="tool-btn" onclick="document.getElementById('file-input').click()">üìÇ Load File</button>
            <button class="tool-btn" onclick="downloadFountain()">üìÑ Exp. Fountain</button>
            <button class="tool-btn" onclick="showStats()">üìä Stats</button>
            <button class="tool-btn" onclick="switchView('storyboard')">üìå Board</button>
            <button class="tool-btn" onclick="switchView('script')">üñ®Ô∏è Script View</button>
            <button class="tool-btn" onclick="showCharacterManagement()">üé≠ Characters</button>
            <button class="tool-btn" onclick="showMetadataEditor()">üìù Metadata</button> 
            <input type="file" id="file-input" accept=".json,.fountain,.txt" class="hidden" onchange="handleFileUpload(this)">
        </div>
        
        <input type="text" id="search-input" placeholder="üîç Filter scenes..." oninput="handleSearch(this.value)">
        <button class="add-btn" onclick="addNewCard()">+ New Scene</button>
        
        <ul class="card-list" id="cardList"></ul>
    </div>

    <div id="main">
        
        <div id="editor-view" class="view-container visible">
            <div id="empty-state" style="text-align: center; opacity: 0.5; margin-top: 100px;">
                <h3>Select or Create a Scene</h3>
            </div>
            
            <div id="editor" class="editor-card hidden">
                
                <div class="scene-header-group">
                    <div id="screen-time-estimate" style="float: right;"></div>
                    <div id="scene-number-display" style="font-size: 1.1em; font-weight: bold; color: #f1c40f; padding: 5px 0 15px 0;"></div>
                    <div class="field-group">
                        <label>Scene Header</label>
                        <input type="text" id="inp-header" placeholder="EXT. LOCATION - TIME or MONTAGE - TYPE" oninput="updateHeader(this.value);">
                    </div>
                </div>

                <div class="field-group">
                    <label>Location (Auto-Extracted)</label>
                    <input type="text" id="inp-location" placeholder="POLICE STATION" oninput="updateCurrentCard('location', this.value);">
                </div>

                <div class="meta-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                    <div class="field-group">
                        <label>Characters</label>
                        <input type="text" id="inp-chars" list="character-list" placeholder="Bubba, Sheriff..." oninput="updateCurrentCard('chars', this.value)">
                    </div>
                    <div class="field-group">
                        <label>Props</label>
                        <input type="text" id="inp-props" placeholder="Red Car..." oninput="updateCurrentCard('props', this.value)">
                    </div>
                </div>
                <div class="field-group">
                    <label>Opening Action / Scene Notes</label>
                    <textarea rows="4" id="inp-notes" placeholder="Describe initial action..." oninput="updateCurrentCard('notes', this.value)"></textarea>
                </div>
                <div class="field-group">
                    <label>Tags</label>
                    <input type="text" id="inp-tags" placeholder="Flashback, Montage..." oninput="updateCurrentCard('tags', this.value)">
                </div>
                <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">

                <div id="montage-editor-block" class="hidden">
                    <label>Montage Elements (Drag to reorder)</label>
                    <ul id="montageList" style="list-style: none; padding: 0; margin: 5px 0;"></ul>
                    <button onclick="addMontageItem()" style="margin-top:10px; cursor:pointer;">+ Add Montage Item</button>
                    <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">
                </div>
                
                <div id="sequence-editor-block">
                    <label>Dialogue and Inter-Dialogue Action Sequence</label>
                    <table class="sequence-table">
                        <thead><tr><th width="25%">Character / Action</th><th width="15%">Context / Style</th><th>Dialogue / Action Content</th><th width="5%"></th></tr></thead>
                        <tbody id="sequenceBody"></tbody>
                    </table>
                    <button onclick="addSequenceItem('Character')" style="margin-top:10px; cursor:pointer;">+ Add Dialogue Line</button>
                    <button onclick="addSequenceItem('Action', null, 'TITLE CARD')" style="margin-top:10px; cursor:pointer;">+ Add Title Card</button>
                    <button onclick="addSequenceItem('Action')" style="margin-top:10px; cursor:pointer;">+ Add Action Block</button>
                </div>

                <button onclick="deleteCurrentCard()" style="float:right; margin-top:10px; color:red; cursor:pointer;">Delete</button>
            </div>
        </div>

        <div id="storyboard-view" class="view-container">
            <div class="board-grid" id="boardGrid"></div>
        </div>

        <div id="script-view" class="view-container">
            <div id="script-content"></div>
            <button id="print-button" onclick="window.print()" style="position:fixed; bottom:20px; right:20px; padding:10px 20px; background:#27ae60; color:white; border:none; cursor:pointer;">Print PDF</button>
        </div>
    </div>

    <div id="stats-modal" onclick="this.style.display='none'" style="display: none;">
        <div class="stats-box" onclick="event.stopPropagation()">
            <h2 style="margin-top:0">Script Statistics</h2>
            <div id="stats-content"></div>
            <button onclick="document.getElementById('stats-modal').style.display='none'" style="width:100%; margin-top:20px; padding:10px;">Close</button>
        </div>
    </div>
    
    <div id="char-modal" onclick="this.style.display='none'" style="display: none;">
        <div class="stats-box" onclick="event.stopPropagation()" style="width: 600px;">
            <h2 style="margin-top:0">üé≠ Character Management</h2>
            <p>Use the **Proxy For** dropdown to merge generic or temporary character names into their final name. This helps with consistency and statistics.</p>
            
            <table style="width: 100%; font-size: 0.9em; margin-top: 15px;">
                <thead>
                    <tr>
                        <th style="text-align: left; width: 25%;">Character Name</th>
                        <th style="text-align: left; width: 20%;">Proxy For</th>
                        <th style="text-align: left; width: 50%;">Description / Notes</th>
                    </tr>
                </thead>
                <tbody id="charManagementBody">
                    </tbody>
            </table>
            
            <button onclick="document.getElementById('char-modal').style.display='none'" style="width:100%; margin-top:20px; padding:10px;">Done</button>
        </div>
    </div>

    <div id="metadata-modal" onclick="this.style.display='none'" style="display: none;">
        <div class="stats-box" onclick="event.stopPropagation()" style="width: 450px;">
            <h2 style="margin-top:0">üìù Script Metadata</h2>
            <p>Manage the **Title**, **Author**, and **Global Transitions** that appear on the title page and before the first scene.</p>
            
            <div class="field-group" style="margin-bottom: 15px;">
                <label>Title</label>
                <input type="text" id="meta-title" oninput="updateMetadata('title', this.value)">
            </div>
            
            <div class="field-group" style="margin-bottom: 15px;">
                <label>Author</label>
                <input type="text" id="meta-author" oninput="updateMetadata('author', this.value)">
            </div>
            
            <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">

            <label>Global Transitions (e.g., FADE IN:)</label>
            <ul id="globalTransitionList" style="list-style: none; padding: 0; margin: 5px 0;"></ul>
            <button onclick="addGlobalTransition()" style="margin-top:10px; cursor:pointer;">+ Add Transition</button>
            
            <button onclick="document.getElementById('metadata-modal').style.display='none'" style="width:100%; margin-top:20px; padding:10px;">Done</button>
        </div>
    </div>

    <script>
        // --- STATE ---
        let cards = [];
        const EMPTY_CARD = { id: Date.now(), header: 'INT. NEW SCENE - DAY', location: 'NEW SCENE', chars: '', props: '', notes: '', tags: '', sequence: [], montage: [], sceneNumber: '' };
        let scriptMetadata = { title: 'UNTITLED SCREENPLAY', author: '', transitions: [], characterProxies: {} }; 
        let activeCardId = null;
        let dragStartIndex;
        let currentSearchTerm = '';
        let currentView = 'editor'; 
        
        const ACTION_STYLES = [
            { value: '', label: 'Action Block' },
            { value: 'TITLE CARD', label: 'TITLE CARD' },
            { value: 'INTERTITLE', label: 'INTERTITLE' },
            { value: 'FADE IN', label: 'FADE IN' },
            { value: 'FADE OUT', label: 'FADE OUT' },
            { value: 'CUT TO', label: 'CUT TO' },
            { value: 'DISSOLVE TO', label: 'DISSOLVE TO' },
            { value: 'FADE TO BLACK', label: 'FADE TO BLACK' },
            { value: 'END OF ACT', label: 'END OF ACT' },
            { value: 'END OF SCENE', label: 'END OF SCENE' },
            { value: 'A BEAT', label: 'A BEAT' },
            { value: 'BEAT', label: 'BEAT' },
            { value: 'INTERCUT', label: 'INTERCUT' }
        ];

        // Add common transitions and all-caps action elements to this list for parsing
        const ALL_CAPS_ACTION_ELEMENTS = [
            'FADE IN', 'FADE OUT', 'FADE TO BLACK', 'FADE TO WHITE',
            'CUT TO', 'DISSOLVE TO', 'SMASH CUT TO', 'QUICK CUT TO',
            'BACK TO SCENE', 'END OF ACT', 'BEGIN ACT', 'END OF SCENE',
            'A BEAT', 'BEAT', 'CONTINUOUS', 'INTERCUT',
        ];
        
        const ALL_TRANSITIONS_AND_ACTIONS = [
            ...ACTION_STYLES.map(s => s.value.toUpperCase()).filter(v => v !== ''),
            ...ALL_CAPS_ACTION_ELEMENTS.map(a => a.toUpperCase())
        ];


        // --- INIT ---
        window.onload = () => {
            const saved = localStorage.getItem('screenplayData');
            const savedMeta = localStorage.getItem('scriptMetadata');
            const theme = localStorage.getItem('theme');
            if (saved) {
                cards = JSON.parse(saved);
                
                cards.forEach(card => {
                    // Migration: Ensure sceneNumber exists
                    if (!card.sceneNumber) card.sceneNumber = '';
                    
                    if (card.dialog && !card.sequence) {
                        card.sequence = card.dialog.map(d => ({ type: 'Character', content: d.character, text: d.text, context: '', contd: false, parenthetical: '' }));
                        delete card.dialog;
                    }
                    
                    card.sequence.forEach(s => {
                        if (s.type === 'Character') {
                            migrateDialogueFields(s);
                        } else if (s.type === 'Action') {
                            if (s.content !== undefined) {
                                s.text = s.content;
                                delete s.content;
                            }
                            if (s.style === undefined) {
                                s.style = '';
                            }
                        }
                    });

                    if (!card.location) { card.location = extractLocation(card.header); }
                });
            }
            if (savedMeta) {
                scriptMetadata = JSON.parse(savedMeta);
                if (!scriptMetadata.characterProxies) {
                    scriptMetadata.characterProxies = {};
                }
            }
            if (theme === 'dark') document.body.classList.add('dark-mode');
            
            renumberScenes(); 
            updateCharacterList();
            renderList();
        };

        // Ensures older data has the new structured fields
        function migrateDialogueFields(s) {
            if (!s.context) s.context = '';
            if (s.contd === undefined) s.contd = false;

            if (s.style !== undefined && s.type === 'Character') {
                const parts = s.style.split(',').map(p => p.trim());
                let parentheticals = [];

                parts.forEach(p => {
                    const upperP = p.toUpperCase();
                    if (upperP === 'V.O.' || upperP === 'V.O') {
                        s.context = 'V.O.';
                    } else if (upperP === 'O.S.' || upperP === 'O.S') {
                        s.context = 'O.S.';
                    } else if (upperP.includes('CONT\'D')) {
                        s.contd = true;
                    } else if (p.length > 0) {
                        parentheticals.push(p);
                    }
                });

                s.parenthetical = parentheticals.join(', ');
                delete s.style;
            } 
            
            if (s.parenthetical === undefined && s.style === undefined) {
                s.parenthetical = '';
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }

        function switchView(viewName) {
            currentView = viewName;
            
            document.querySelectorAll('.view-container').forEach(el => el.classList.remove('visible'));
            
            if (viewName === 'editor') { 
                document.getElementById('editor-view').classList.add('visible'); 
                if (activeCardId) loadEditor(activeCardId, false);
                renderList(); 
            }
            else if (viewName === 'storyboard') { 
                document.getElementById('storyboard-view').classList.add('visible'); 
                renderStoryboard(); 
            }
            else if (viewName === 'script') { 
                document.getElementById('script-view').classList.add('visible'); 
                generateScript(); 
            }
        }

        function extractLocation(header) {
            if (!header) return '';
            const upperHeader = header.toUpperCase().trim();
            const parts = upperHeader.split(' - ');

            if (upperHeader.startsWith('MONTAGE')) {
                return upperHeader;
            }

            if (parts.length >= 2) {
                let locationPart = parts[0];
                const prefixRegex = /^(INT|EXT|EST|I\/E|INT\/EXT)\.\s*/;
                locationPart = locationPart.replace(prefixRegex, '').trim();
                return locationPart;
            } else if (parts.length === 1) {
                const prefixRegex = /^(INT|EXT|EST|I\/E|INT\/EXT)\.\s*/;
                return upperHeader.replace(prefixRegex, '').trim();
            }
            return upperHeader;
        }

        function updateHeader(value) {
            updateCurrentCard('header', value);
            const location = extractLocation(value);
            updateCurrentCard('location', location);
            document.getElementById('inp-location').value = location;
            toggleMontageEditor(value);
        }
        
        function addNewCard() {
            const newCard = { ...EMPTY_CARD, id: Date.now(), sceneNumber: '' }; 
            
            if (activeCardId) {
                const activeIndex = cards.findIndex(c => c.id === activeCardId);
                cards.splice(activeIndex + 1, 0, newCard); 
            } else {
                cards.push(newCard);
            }
            
            renumberScenes(); 
            activeCardId = newCard.id;
            switchView('editor'); 
            saveData(); 
            loadEditor(newCard.id);
        }

        function saveData() {
            localStorage.setItem('screenplayData', JSON.stringify(cards));
            localStorage.setItem('scriptMetadata', JSON.stringify(scriptMetadata));
            updateCharacterList();
            if(currentView === 'editor') {
                renderList();
                if(activeCardId) updateScreenTimeEstimate();
            }
        }

        function updateCurrentCard(field, value) {
            const card = cards.find(c => c.id === activeCardId);
            if(card) { card[field] = value; saveData(); }
        }
        
        // --- SCENE NUMBERING LOGIC ---

        function renumberScenes() {
            const currentNumbers = cards.map(c => c.sceneNumber);
            const primaryNumbers = new Set(
                currentNumbers
                    .map(n => parseInt(n))
                    .filter(n => !isNaN(n))
            );

            let nextPrimaryNumber = primaryNumbers.size > 0 ? Math.max(...primaryNumbers) + 1 : 1;

            cards.forEach(card => {
                if (!parseInt(card.sceneNumber)) {
                    card.sceneNumber = nextPrimaryNumber.toString();
                    nextPrimaryNumber++;
                } else if (parseInt(card.sceneNumber) >= nextPrimaryNumber) {
                    nextPrimaryNumber = parseInt(card.sceneNumber) + 1;
                }
            });

            for (let i = 1; i < cards.length; i++) {
                const current = cards[i];
                const previous = cards[i - 1];

                const primaryCurrent = parseInt(current.sceneNumber);
                const primaryPrev = parseInt(previous.sceneNumber);

                if (primaryCurrent === primaryPrev) {
                    const base = primaryPrev;
                    let suffix = 'A';
                    
                    for (let j = i - 1; j >= 0; j--) {
                        if (cards[j].sceneNumber.startsWith(base.toString())) {
                            const lastSuffix = cards[j].sceneNumber.replace(base.toString(), '');
                            if (lastSuffix) {
                                suffix = String.fromCharCode(lastSuffix.charCodeAt(0) + 1);
                                break;
                            }
                        } else if (parseInt(cards[j].sceneNumber) < base) {
                            break;
                        }
                    }
                    current.sceneNumber = base + suffix;
                }
            }
            saveData();
        }

        // --- CHARACTER MANAGEMENT LOGIC ---

        function resolveCharacterName(name) {
            const upperName = name.toUpperCase().trim();
            if (scriptMetadata.characterProxies[upperName]) {
                return scriptMetadata.characterProxies[upperName].proxyFor;
            }
            return upperName;
        }

        function getAllCharacterNames() {
            const charSet = new Set();
            cards.forEach(c => {
                c.chars.split(',').forEach(n => { if(n.trim()) charSet.add(n.trim().toUpperCase()); });
                c.sequence && c.sequence.forEach(s => { 
                    if (s.type === 'Character' && s.content.trim()) charSet.add(s.content.trim().toUpperCase()); 
                });
            });
            return Array.from(charSet).sort();
        }

        function updateCharacterList() {
            const allNames = getAllCharacterNames();
            const newProxies = {};

            allNames.forEach(name => {
                const existing = scriptMetadata.characterProxies[name];
                if (existing) {
                    newProxies[name] = existing;
                } else {
                    newProxies[name] = { proxyFor: name, description: '' };
                }
            });
            
            for (const name in scriptMetadata.characterProxies) {
                const targetName = scriptMetadata.characterProxies[name].proxyFor;
                const isPresent = allNames.includes(name) || allNames.includes(targetName);
                const isUsedAsTarget = Object.values(newProxies).some(p => p.proxyFor === name && p.proxyFor !== name);

                if (!isPresent && !isUsedAsTarget) {
                    delete scriptMetadata.characterProxies[name];
                }
            }
            
            scriptMetadata.characterProxies = Object.keys(scriptMetadata.characterProxies).reduce((acc, key) => {
                acc[key] = scriptMetadata.characterProxies[key];
                return acc;
            }, {});

            const dl = document.getElementById('character-list');
            dl.innerHTML = '';
            
            const resolvedNames = new Set(Object.values(scriptMetadata.characterProxies).map(p => p.proxyFor));
            resolvedNames.forEach(char => { let opt = document.createElement('option'); opt.value = char; dl.appendChild(opt); });
        }


        // --- EDITOR UI ---
        function loadEditor(id) {
            activeCardId = id;
            const card = cards.find(c => c.id === id);
            
            if (!card) {
                document.getElementById('editor').classList.add('hidden');
                document.getElementById('empty-state').classList.remove('hidden');
                document.getElementById('screen-time-estimate').innerHTML = '';
                document.getElementById('scene-number-display').innerText = ''; 
                return;
            }

            document.getElementById('empty-state').classList.add('hidden');
            document.getElementById('editor').classList.remove('hidden');
            ['header', 'location', 'chars', 'props', 'notes', 'tags'].forEach(f => document.getElementById('inp-' + f).value = card[f]);
            
            document.getElementById('scene-number-display').innerText = `#${card.sceneNumber}`;
            
            toggleMontageEditor(card.header); 
            
            if (card.header.toUpperCase().startsWith('MONTAGE')) {
                renderMontageList(card.montage || []);
            } else {
                renderSequenceTable(card.sequence || []);
            }
            
            renderList();
            updateScreenTimeEstimate();
        }

        // --- TIME ESTIMATION FUNCTIONS (unchanged) ---

        function countWords(text) {
            if (!text || typeof text !== 'string') return 0;
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }
        
        function estimateScreenTime(card) {
            if (!card) return 0;

            const ACTION_WORDS_PER_PAGE = 250; 
            const DIALOGUE_WORDS_PER_PAGE = 130; 
            const LINES_PER_PAGE = 55;

            let pageEquivalent = 0;
            let totalActionWords = 0;
            let totalDialogueWords = 0;

            pageEquivalent += (2 / LINES_PER_PAGE); 
            
            totalActionWords += countWords(card.notes);

            card.sequence.forEach(s => {
                if (s.type === 'Action') {
                    totalActionWords += countWords(s.text);
                    pageEquivalent += (2 / LINES_PER_PAGE); 
                } else if (s.type === 'Character') {
                    totalDialogueWords += countWords(s.text);
                    totalActionWords += countWords(s.parenthetical);
                    totalActionWords += countWords(s.context.replace(/[()]/g, ''));
                    pageEquivalent += (2 / LINES_PER_PAGE); 
                }
            });

            if (card.header.toUpperCase().startsWith('MONTAGE')) {
                pageEquivalent += (card.montage.length / 27); 
            }

            const actionPages = totalActionWords / ACTION_WORDS_PER_PAGE; 
            const dialoguePages = totalDialogueWords / DIALOGUE_WORDS_PER_PAGE; 
            
            pageEquivalent += actionPages + dialoguePages;

            return Math.max(0.1, Math.round(pageEquivalent * 10) / 10);
        }

        function updateScreenTimeEstimate() {
            const card = cards.find(c => c.id === activeCardId);
            if (!card) return;
            const time = estimateScreenTime(card);
            document.getElementById('screen-time-estimate').innerHTML = `‚è±Ô∏è Est. Time: **${time} min**`;
        }
        
        function calculateTotalScriptTime() {
            let totalTime = 0;
            cards.forEach(card => {
                totalTime += estimateScreenTime(card);
            });
            return Math.round(totalTime * 10) / 10; 
        }

        // Sequence Rendering (unchanged)
        function renderSequenceTable(sequence) {
            const tbody = document.getElementById('sequenceBody');
            tbody.innerHTML = '';
            
            if (!sequence) return;

            sequence.forEach((item, i) => {
                
                if (item.type === 'Character') {
                    migrateDialogueFields(item); 
                    
                    const contextSelect = `
                        <select onchange="updSeq(${i}, 'context', this.value)">
                            <option value="" ${item.context === '' ? 'selected' : ''}></option>
                            <option value="V.O." ${item.context === 'V.O.' ? 'selected' : ''}>V.O.</option>
                            <option value="O.S." ${item.context === 'O.S.' ? 'selected' : ''}>O.S.</option>
                        </select>`;
                        
                    const contdCheckbox = `
                        <label class="contd-checkbox">
                            <input type="checkbox" ${item.contd ? 'checked' : ''} onchange="updSeq(${i}, 'contd', this.checked)"> 
                            CONT'D
                        </label>`;
                        
                    tbody.innerHTML += `<tr class="row-character" draggable="true" data-index="${i}" ondragstart="startDragSequence(event)" ondragover="dragOverSequence(event)" ondrop="dropSequence(event)">
                        <td>
                            <div class="dialog-character-group">
                                <input list="character-list" class="sequence-input" placeholder="Character Name" value="${item.content || ''}" oninput="updSeq(${i}, 'content', this.value)">
                                <input class="sequence-input" placeholder="(parenthetical action)" style="border-bottom: none;" value="${item.parenthetical || ''}" oninput="updSeq(${i}, 'parenthetical', this.value)">
                            </div>
                        </td>
                        <td class="col-dialog-controls">
                            ${contextSelect}
                            ${contdCheckbox}
                        </td>
                        <td class="col-content-dialog">
                            <textarea rows="4" placeholder="Dialogue Text..." oninput="updSeq(${i}, 'text', this.value)">${item.text || ''}</textarea>
                        </td>
                        <td class="col-del" onclick="delSeq(${i})">√ó</td>
                    </tr>`;
                } else if (item.type === 'Action') {
                    const styleUpper = (item.style || '').toUpperCase();
                    let actionStyleLabel = 'ACTION';
                    
                    const styleOptions = ACTION_STYLES.map(opt => 
                        `<option value="${opt.value}" ${styleUpper === opt.value.toUpperCase() ? 'selected' : ''}>${opt.label}</option>`
                    ).join('');

                    tbody.innerHTML += `<tr class="row-action" draggable="true" data-index="${i}" ondragstart="startDragSequence(event)" ondragover="dragOverSequence(event)" ondrop="dropSequence(event)">
                        <td>${actionStyleLabel}</td>
                        <td>
                            <select class="action-style-select" onchange="updSeq(${i}, 'style', this.value)">
                                ${styleOptions}
                            </select>
                        </td>
                        <td class="col-content-dialog">
                            <textarea class="action-content-textarea" rows="4" placeholder="Action content..." oninput="updSeq(${i}, 'text', this.value)">${item.text || ''}</textarea>
                        </td>
                        <td class="col-del" onclick="delSeq(${i})">√ó</td>
                    </tr>`;
                }
            });
        }
        
        function startDragSequence(event) {
            dragStartIndex = +event.target.closest('tr').dataset.index;
            event.dataTransfer.setData('text/plain', dragStartIndex);
            event.target.closest('tr').style.opacity = '0.4';
        }

        function dragOverSequence(event) {
            event.preventDefault();
            event.target.closest('tr').style.borderTop = '2px solid var(--accent)';
        }
        
        function dropSequence(event) {
            event.preventDefault();
            const fromIndex = dragStartIndex;
            const toIndex = +event.target.closest('tr').dataset.index;
            event.target.closest('tr').style.opacity = '1';
            event.target.closest('tr').style.borderTop = '';

            if (fromIndex !== toIndex) {
                const sequence = cards.find(c => c.id === activeCardId).sequence;
                const item = sequence[fromIndex];
                sequence.splice(fromIndex, 1);
                sequence.splice(toIndex, 0, item);
                saveData();
                renderSequenceTable(sequence);
            }
        }

        function updSeq(i, f, v) { 
            const item = cards.find(c => c.id === activeCardId).sequence[i];
            
            if (f === 'content' || f === 'text' || f === 'parenthetical' || f === 'context') {
                item[f] = v;
            } else if (f === 'contd') { 
                item.contd = v; 
            }
            else if (f === 'style' && item.type === 'Action') {
                 item[f] = v;
                 renderSequenceTable(cards.find(c => c.id === activeCardId).sequence);
            }

            saveData(); 
            updateScreenTimeEstimate();
        }

        function addSequenceItem(type, index = null, style = '') { 
            const card = cards.find(c => c.id === activeCardId);
            const newItem = type === 'Character' 
                ? { type: 'Character', content: '', context: '', contd: false, parenthetical: '', text: '' }
                : { type: 'Action', style: style, text: '' }; 
            
            if (index !== null) {
                card.sequence.splice(index, 0, newItem);
            } else {
                card.sequence.push(newItem);
            }
            
            saveData(); 
            renderSequenceTable(card.sequence); 
            updateScreenTimeEstimate();
        }

        function delSeq(i) { 
            cards.find(c => c.id === activeCardId).sequence.splice(i, 1); 
            saveData(); 
            renderSequenceTable(cards.find(c => c.id === activeCardId).sequence); 
            updateScreenTimeEstimate();
        }

        function deleteCurrentCard() { 
            if(confirm("Delete scene?")) { 
                cards = cards.filter(c => c.id !== activeCardId); 
                activeCardId = null; 
                document.getElementById('editor').classList.add('hidden'); 
                document.getElementById('empty-state').classList.remove('hidden');
                renumberScenes(); 
                saveData(); 
            } 
        }


        // --- MONTAGE UI AND LOGIC (unchanged) ---
        function toggleMontageEditor(header) {
            const isMontage = (header || document.getElementById('inp-header').value).toUpperCase().startsWith('MONTAGE');
            document.getElementById('montage-editor-block').classList.toggle('hidden', !isMontage);
            document.getElementById('sequence-editor-block').classList.toggle('hidden', isMontage);
            
            const currentCard = cards.find(c => c.id === activeCardId);
            if (!currentCard) return;

            if (isMontage) {
                if (currentCard.sequence && currentCard.sequence.length > 0) { currentCard.sequence = []; renderSequenceTable([]); }
            } else {
                if (currentCard.montage && currentCard.montage.length > 0) { currentCard.montage = []; renderMontageList([]); }
            }
        }

        function renderMontageList(montage) {
            const list = document.getElementById('montageList');
            list.innerHTML = '';
            montage.forEach((item, i) => {
                const li = document.createElement('li');
                li.style.cssText = 'padding: 8px 0; border-bottom: 1px solid var(--border); display: flex; align-items: center; cursor: grab;';
                li.dataset.index = i;
                li.draggable = true;
                
                li.innerHTML = `
                    <span style="margin-right: 10px; cursor: move;">::</span>
                    <input type="text" value="${item}" style="flex-grow: 1; border: none; background: transparent; padding: 0 8px;" oninput="updMontageItem(${i}, this.value)">
                    <button onclick="delMontageItem(${i})" style="color: #e74c3c; background: none; border: none; cursor: pointer; padding: 5px;">Delete</button>
                `;
                list.appendChild(li);

                li.addEventListener('dragstart', function() { dragStartIndex = +this.dataset.index; this.style.opacity = '0.4'; });
                li.addEventListener('dragover', function(e) { e.preventDefault(); });
                li.addEventListener('dragenter', function() { this.style.backgroundColor = 'rgba(52, 152, 219, 0.1)'; });
                li.addEventListener('dragleave', function() { this.style.backgroundColor = 'transparent'; });
                li.addEventListener('drop', function() { swapMontageItems(dragStartIndex, +this.dataset.index); this.style.opacity = '1'; this.style.backgroundColor = 'transparent'; });
                li.addEventListener('dragend', function() { this.style.opacity = '1'; });
            });
        }

        function updMontageItem(i, v) { cards.find(c => c.id === activeCardId).montage[i] = v; saveData(); updateScreenTimeEstimate(); }
        function addMontageItem() { cards.find(c => c.id === activeCardId).montage.push(''); saveData(); renderMontageList(cards.find(c => c.id === activeCardId).montage); updateScreenTimeEstimate(); }
        function delMontageItem(i) { cards.find(c => c.id === activeCardId).montage.splice(i, 1); saveData(); renderMontageList(cards.find(c => c.id === activeCardId).montage); updateScreenTimeEstimate(); }
        function swapMontageItems(fromIndex, toIndex) {
            const montage = cards.find(c => c.id === activeCardId).montage;
            const item = montage[fromIndex];
            montage.splice(fromIndex, 1);
            montage.splice(toIndex, 0, item);
            saveData();
            renderMontageList(montage);
            updateScreenTimeEstimate();
        }

        // --- RENDERING LISTS ---
        function getColorClass(h) {
            h = (h || '').toUpperCase();
            if(h.startsWith('MONTAGE')) return 'scene-montage';
            if(h.includes('INT') && h.includes('EXT')) return 'scene-mix';
            if(h.startsWith('INT')) return 'scene-int';
            if(h.startsWith('EXT')) return 'scene-ext';
            return '';
        }

        function renderList() {
            const list = document.getElementById('cardList');
            list.innerHTML = '';
            cards.forEach((card, idx) => {
                const search = `${card.header} ${card.chars} ${card.tags} ${card.notes} ${card.location}`.toLowerCase();
                if(currentSearchTerm && !search.includes(currentSearchTerm)) return;
                const li = document.createElement('li');
                li.className = `card-item ${getColorClass(card.header)} ${card.id === activeCardId ? 'active' : ''}`;
                li.innerHTML = `
                    <span style="font-size: 0.9em; font-weight: bold; color: #f1c40f; margin-right: 5px;">#${card.sceneNumber || 'N/A'}</span>
                    <strong>${card.header}</strong><br>
                    <small>${card.location || ''} | ${card.tags || ''}</small>`;
                li.onclick = () => { switchView('editor'); loadEditor(card.id); };
                if(!currentSearchTerm) { li.draggable = true; li.dataset.index = idx; addDragEvents(li); }
                list.appendChild(li);
            });
        }

        function addDragEvents(el) {
            el.addEventListener('dragstart', function() { dragStartIndex = +this.dataset.index; this.style.opacity = '0.4'; });
            el.addEventListener('dragover', function(e) { e.preventDefault(); });
            el.addEventListener('dragenter', function() { this.classList.add('over'); });
            el.addEventListener('dragleave', function() { this.classList.remove('over'); });
            el.addEventListener('drop', function() { swapItems(dragStartIndex, +this.dataset.index); this.classList.remove('over'); this.style.opacity = '1'; });
            el.addEventListener('dragend', function() { this.style.opacity = '1'; });
        }
        function swapItems(f, t) { 
            const i = cards[f]; 
            cards.splice(f, 1); 
            cards.splice(t, 0, i); 
            renumberScenes(); 
            saveData(); 
            if(currentView==='editor') renderList(); 
            else renderStoryboard(); 
        }

        // --- STORYBOARD RENDERING ---
        function renderStoryboard() {
            const grid = document.getElementById('boardGrid');
            grid.innerHTML = '';
            grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; padding: 10px;';
            
            cards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `board-card ${getColorClass(card.header)}`;
                div.style.cssText = 'background: var(--card-bg); padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-left: 6px solid; min-height: 150px; position: relative; cursor: pointer;';
                div.innerHTML = `
                    <div style="font-size: 0.8em; opacity: 0.6; margin-bottom: 5px;">#${card.sceneNumber} / Index: ${idx + 1}</div>
                    <strong style="display: block; margin-bottom: 5px;">${card.header}</strong>
                    <p style="font-size: 0.9em; margin: 0 0 10px 0; max-height: 50px; overflow: hidden; opacity: 0.8;">${card.notes.substring(0, 100)}...</p>
                    <small style="font-style: italic; display: block; margin-top: 10px;">Location: ${card.location || 'N/A'}</small>
                    <small style="font-style: italic; display: block;">Tags: ${card.tags}</small>
                `;
                div.onclick = () => { switchView('editor'); loadEditor(card.id); };
                grid.appendChild(div);
            });
        }


        // --- EXPORT / IMPORT (Fountain Parsing is FIXED) ---
        function saveJSON() {
            const blob = new Blob([JSON.stringify({cards: cards, metadata: scriptMetadata})], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'screenplay.json'; a.click();
        }

        function downloadFountain() {
            let f = "";
            
            if (scriptMetadata.title || scriptMetadata.author) {
                f += `Title: ${scriptMetadata.title}\n`;
                if(scriptMetadata.author) f += `Author: ${scriptMetadata.author}\n\n`;
                f += "\n\n";
            }
            
            scriptMetadata.transitions.forEach(t => f += `${t}\n\n`);

            cards.forEach(c => {
                f += c.header.toUpperCase() + "\n\n";
                
                if(c.notes) f += c.notes + "\n\n";
                
                if (c.header.toUpperCase().startsWith('MONTAGE')) {
                    c.montage.forEach(item => { f += `-- ${item}\n`; });
                    f += "\n";
                } else {
                    c.sequence.forEach(s => {
                        if (s.type === 'Character') {
                            f += s.content.toUpperCase();
                            
                            const inlineElements = [];
                            if (s.context) inlineElements.push(s.context);
                            if (s.contd) inlineElements.push("CONT'D");
                            
                            const styleContent = s.parenthetical ? s.parenthetical.split(',').map(p => p.trim()).filter(p => p.length > 0) : [];
                            
                            const allParentheticals = [...inlineElements, ...styleContent].join(', ');
                            
                            const finalTag = allParentheticals ? ` (${allParentheticals})` : '';
                            f += finalTag + "\n" + s.text + "\n\n";

                        } else if (s.type === 'Action') {
                            const styleUpper = (s.style || '').toUpperCase();
                            
                            if (styleUpper === 'TITLE CARD' || styleUpper === 'INTERTITLE') {
                                const prefix = styleUpper.startsWith('INTERTITLE') ? 'INTERTITLE' : 'TITLE CARD';
                                f += `${prefix}: ${s.text}\n\n`; 
                            } else if (ALL_TRANSITIONS_AND_ACTIONS.includes(styleUpper)) {
                                if (s.text) f += s.text + "\n"; 
                                f += `${styleUpper}\n\n`; 
                            } else {
                                f += s.text + "\n\n";
                            }
                        }
                    });
                }
                
                const finalTags = c.tags.split(',').filter(t => t.trim().toUpperCase().includes('FADE OUT') || t.trim().toUpperCase().includes('CUT TO') || t.trim().toUpperCase().includes('DISSOLVE TO'));
                finalTags.forEach(t => f += `${t.trim().toUpperCase()}.\n\n`);
            });
            const blob = new Blob([f], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'screenplay.fountain'; a.click();
        }

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const content = e.target.result;
                let successMessage = "";
                
                if(file.name.endsWith('.json')) {
                    try { 
                        const loadedData = JSON.parse(content);
                        if (Array.isArray(loadedData)) { 
                            cards = loadedData;
                        } else if (loadedData.cards) { 
                            cards = loadedData.cards;
                            scriptMetadata = loadedData.metadata || scriptMetadata; 
                        }
                        
                        cards.forEach(card => {
                            if (!card.sceneNumber) card.sceneNumber = ''; 
                            if (card.dialog && !card.sequence) {
                                card.sequence = card.dialog.map(d => ({ type: 'Character', content: d.character, text: d.text, context: '', contd: false, parenthetical: '' }));
                                delete card.dialog;
                            }
                            card.sequence.forEach(s => {
                                if (s.type === 'Character') migrateDialogueFields(s);
                                else if (s.type === 'Action') { 
                                    if (s.content !== undefined) { s.text = s.content; delete s.content; }
                                    if (s.style === undefined) { s.style = ''; } 
                                }
                            });
                            if (!card.location) { card.location = extractLocation(card.header); }
                        });
                        successMessage = "JSON Loaded! Total Scenes: " + cards.length;
                    } catch(e) { 
                        alert("Invalid JSON file format. Check console for details."); 
                        console.error(e);
                        return; 
                    }
                } else {
                    parseFountainImport(content); 
                    successMessage = "Imported " + cards.length + " scenes from text/fountain.";
                }
                
                renumberScenes(); 
                saveData(); 

                if (cards.length > 0) {
                    switchView('editor'); 
                    activeCardId = cards[0].id;
                    loadEditor(cards[0].id);
                } else {
                    activeCardId = null;
                    loadEditor(null);
                }
                
                input.value = ''; 
            };
            
            reader.readAsText(file);
        }

        function parseFountainImport(text) {
            cards = [];
            scriptMetadata = { title: 'UNTITLED SCREENPLAY', author: '', transitions: [], characterProxies: {} }; 
            const lines = text.split(/\r?\n/);
            let currentCard = null;
            let isTitlePage = true;
            let actionBuffer = []; 
            
            const headerRegex = /^(INT\.|EXT\.|EST\.|I\/E|INT\/EXT|MONTAGE)/i; 
            const characterLineRegex = /^([A-Z0-9\s,.'"-]+)(\s+\(.+\))*\s*$/; 

            const flushActionBuffer = (isSceneStart) => {
                if (!currentCard || actionBuffer.length === 0) return;
                
                let style = '';
                let text = actionBuffer.join('\n');

                const lastLine = actionBuffer[actionBuffer.length - 1].toUpperCase().trim();
                const matchedStyle = ALL_TRANSITIONS_AND_ACTIONS.find(s => s === lastLine); 
                
                if (matchedStyle && ['FADE IN', 'FADE OUT', 'CUT TO', 'DISSOLVE TO', 'FADE TO BLACK'].includes(matchedStyle)) {
                    style = matchedStyle;
                    actionBuffer.pop(); 
                    text = actionBuffer.join('\n');
                }

                if (text.trim().length > 0 || style !== '') {
                    currentCard.sequence.push({ 
                        type: 'Action', 
                        style: style, 
                        text: text.trim() 
                    }); 
                }
                
                actionBuffer = [];
            };

            const isLikelyAction = (line) => {
                const trim = line.trim();
                if (trim.length > 0 && /[A-Z]/.test(trim[0]) && /[a-z]/.test(trim[1])) { return true; }
                return false;
            };

            lines.forEach(line => {
                const trim = line.trim();
                if(!trim) { flushActionBuffer(); return; } 

                const trimUpper = trim.toUpperCase();
                
                if (isTitlePage) {
                    if (headerRegex.test(trim) || trim.startsWith('.')) { 
                        isTitlePage = false; 
                    } 
                    else if (trim.includes(':') && trim.length < 50) {
                        const parts = trim.split(':');
                        const key = parts[0].trim().toLowerCase();
                        const value = parts.slice(1).join(':').trim();
                        if (key === 'title') scriptMetadata.title = value;
                        else if (key === 'author') scriptMetadata.author = value;
                        return;
                    } 
                    else if (ALL_TRANSITIONS_AND_ACTIONS.includes(trimUpper)) {
                        scriptMetadata.transitions.push(trimUpper);
                        return;
                    }
                    if (isTitlePage) return; 
                }
                
                // 1. SCENE HEADER CHECK
                if(headerRegex.test(trim) || trim.startsWith('.')) {
                    flushActionBuffer(true); 
                    const headerText = trim.replace(/^\./, '').trim();
                    const locationText = extractLocation(headerText);
                    currentCard = { id: Date.now() + Math.random(), header: headerText, location: locationText, chars:'', props:'', notes:'', tags:'', sequence:[], montage:[], sceneNumber: '' }; 
                    cards.push(currentCard);
                    actionBuffer = []; 
                } 
                
                else if (currentCard) {
                    const isMontageBlock = currentCard.header.toUpperCase().startsWith('MONTAGE');
                    const charMatch = trim.match(characterLineRegex); 
                    let lastItem = currentCard.sequence[currentCard.sequence.length - 1];

                    // 2. PRIORITY CHECK: Transition/Special Action at start of line
                    let isSpecialAction = false;
                    const cleanUpperTrim = trimUpper.replace(/\.$/, '').trim(); 
                    
                    const matchedTransition = ALL_TRANSITIONS_AND_ACTIONS.find(s => 
                        cleanUpperTrim.startsWith(s)
                    );

                    if (matchedTransition) {
                        flushActionBuffer();
                        isSpecialAction = true;
                        
                        let remainingText = trim.substring(matchedTransition.length).trim();
                        if (remainingText.startsWith(':')) remainingText = remainingText.substring(1).trim();
                        if (remainingText.endsWith('.')) remainingText = remainingText.substring(0, remainingText.length - 1).trim();

                        currentCard.sequence.push({ 
                            type: 'Action', 
                            style: matchedTransition, 
                            text: remainingText 
                        });
                    }

                    if (isSpecialAction) return;


                    // 3. TITLE CARD CHECK
                    else if (trimUpper.startsWith('TITLE CARD:') || trimUpper.startsWith('INTERTITLE:')) {
                        flushActionBuffer(); 
                        const prefix = trimUpper.startsWith('INTERTITLE:') ? 'INTERTITLE' : 'TITLE CARD';
                        const text = trim.substring(trim.indexOf(':') + 1).trim();
                        currentCard.sequence.push({ type: 'Action', text: text, style: prefix });
                    }
                    
                    // 4. MONTAGE ITEM CHECK
                    else if (isMontageBlock && trim.startsWith('--')) {
                        currentCard.montage.push(trim.substring(2).trim());
                    }
                    
                    // 5. CHARACTER CHECK
                    else if(charMatch && !isMontageBlock) {
                        flushActionBuffer(); 
                        
                        let context = '';
                        let contd = false;
                        let parentheticals = [];
                        let charLineWithoutParentheticals = trim;
                        
                        let match;
                        const parentheticalLineRegex = /\(([^)]+)\)/g; 
                        while ((match = parentheticalLineRegex.exec(trim)) !== null) {
                            const content = match[1].trim();
                            const upperContent = content.toUpperCase();
                            
                            if (upperContent === 'V.O.' || upperContent === 'O.S.') context = upperContent.replace('.', '');
                            else if (upperContent.includes('CONT\'D')) contd = true;
                            else if (content.length > 0) parentheticals.push(content);

                            charLineWithoutParentheticals = charLineWithoutParentheticals.replace(match[0], '').trim();
                        }

                        const characterName = charLineWithoutParentheticals.toUpperCase().trim(); 
                        
                        currentCard.sequence.push({ 
                            type: 'Character', 
                            content: characterName, 
                            context: context,
                            contd: contd,
                            parenthetical: parentheticals.join(', '), 
                            text: '' 
                        });
                        lastItem = currentCard.sequence[currentCard.sequence.length - 1]; 
                    } 

                    // 6. PARENTHETICAL CHECK
                    else if (trim.startsWith('(') && trim.endsWith(')')) {
                        if (lastItem && lastItem.type === 'Character' && !lastItem.text) {
                            const cleanParenthetical = trim.replace(/[()]/g, '').trim();
                            lastItem.parenthetical += (lastItem.parenthetical ? ', ' : '') + cleanParenthetical; 
                        } else {
                            actionBuffer.push(trim);
                        }
                    } 
                    
                    // 7. DIALOGUE / ACTION LINE
                    else if (lastItem && lastItem.type === 'Character') {
                        if (lastItem.text && isLikelyAction(trim)) {
                            actionBuffer.push(trim);
                            flushActionBuffer(); 
                        } else {
                            lastItem.text += (lastItem.text ? '\n' : '') + trim; 
                        }
                    }
                    else {
                        actionBuffer.push(trim);
                    }
                }
            });

            flushActionBuffer();

            cards.forEach(card => {
                const charSet = new Set();
                if (card.sequence) {
                    card.sequence.forEach(s => {
                        if (s.type === 'Character' && s.content) {
                            charSet.add(s.content.trim());
                        }
                    });
                }
                card.chars = Array.from(charSet).join(', ');
            });
        }


        // --- SCRIPT GENERATION ---

        // Standard Screenplay Fixed-Pitch Constraints
        const MAX_LINES_PER_PAGE = 55; // Standard page length (excluding page number)
        const CHAR_WIDTH = 60; // Max characters per action line (approx)

        // Formatting Constants (in columns/characters)
        const CHAR_NAME_COL = 37; // Center point for character name
        const DIALOGUE_COL = 18; // Start column for dialogue block
        const PARENTHETICAL_COL = 26; // Start column for parenthetical block
        const DIALOGUE_WIDTH = 38; // Max width for dialogue block

        // Helper to pad and truncate strings
        function padString(text, col, width) {
            let s = text || '';
            s = s.substring(0, width); 
            
            let paddingNeeded = col;
            
            // Pad the start of the string
            let pad = "&nbsp;".repeat(paddingNeeded);
            return pad + s;
        }

        // Helper to format a guaranteed blank line spacer (CRITICAL FIX)
        function formatSpacer() {
            // Returns a raw HTML string for the dedicated spacer div
            return `<div class="sc-spacer"></div>`;
        }

        // Word wrapping function for fixed width
        function wordWrap(text, width) {
            if (!text) return [""];
            const words = text.split(/\s+/);
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                // Check if adding the word exceeds the width
                if ((currentLine + ' ' + word).trim().length <= width) {
                    currentLine = (currentLine + ' ' + word).trim();
                } else {
                    if (currentLine.length > 0) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine.length > 0) lines.push(currentLine);
            return lines;
        }


        // --- PAGE BUFFER CLASS ---

        class PageBuffer {
            constructor() {
                this.lines = [];
                this.pageCounter = 0;
            }
            
            // Helper to check if the last stored line was the specific spacer DIV (CRITICAL FIX)
            isLastLineBlank() {
                if (this.lines.length === 0) return false;
                const lastLine = this.lines[this.lines.length - 1];
                // Check for the exact spacer element
                return lastLine.includes('<div class="sc-spacer"></div>');
            }

            // Insert lines and handle overflow
            insert(formattedLines, elementClass, forceBreak = false) {
                let html = '';
                
                if (forceBreak && this.lines.length > 0) {
                    html += this.flush();
                }

                // If the entire block won't fit on the remaining lines, flush first
                const linesRemaining = MAX_LINES_PER_PAGE - this.lines.length;
                if (formattedLines.length > linesRemaining && this.lines.length > 0) {
                    html += this.flush();
                }
                
                // Add lines to the current page 
                for (let i = 0; i < formattedLines.length; i++) {
                    const line = formattedLines[i];
                    
                    // CRITICAL BLANK LINE DEDUPLICATION LOGIC - UPDATED
                    const isSpacer = line.includes('<div class="sc-spacer"></div>');

                    // If the previous block ended with a spacer, and the current block starts with one, skip the current one.
                    if (i === 0 && isSpacer && this.isLastLineBlank()) {
                         // Skip this line insertion
                         continue;
                    }

                    // Check again in case the line itself is the 56th line on the page
                    if (this.lines.length >= MAX_LINES_PER_PAGE) {
                        html += this.flush();
                    }
                    
                    // Spacer lines are inserted directly without a surrounding <div> as they already are a <div>
                    const content = isSpacer ? line : `<div class="${elementClass}">${line}</div>`;
                    this.lines.push(content);
                }
                
                return html;
            }

            // Renders the current page and resets the buffer
            flush() {
                if (this.lines.length === 0) return '';
                
                this.pageCounter++;
                const pageNumber = `<div class="sc-page-number">${this.pageCounter}.</div>`;
                const content = this.lines.join('\n');
                
                // Use a single container to simulate the page dimensions
                let pageHtml = `
                    <div class="sc-page">
                        ${pageNumber}
                        ${content}
                    </div>
                `;
                
                this.lines = [];
                return pageHtml;
            }
        }

        // --- FORMATTING FUNCTIONS (using formatSpacer for vertical space) ---

        // 1. Scene Header: INT. LOCATION - TIME
        function formatHeader(headerText) {
            const lines = [];
            lines.push(padString(headerText.toUpperCase(), 0, 55));
            lines.push(formatSpacer()); // Blank line AFTER header
            return lines;
        }

        // 2. Action/Notes Block
        function formatAction(text) {
            const wrappedLines = wordWrap(text, CHAR_WIDTH);
            const paddedLines = wrappedLines.map(line => padString(line, 0, CHAR_WIDTH));
            
            paddedLines.push(formatSpacer()); // Blank line AFTER action
            return paddedLines;
        }

        // 3. Transitions (FADE OUT, CUT TO)
        function formatTransition(text) {
            const lines = [];
            
            lines.push(formatSpacer()); // Blank line BEFORE transition
            
            const transitionText = text.toUpperCase() + '.';
            const rightPad = Math.max(0, CHAR_WIDTH - transitionText.length);
            lines.push(padString(transitionText, rightPad, CHAR_WIDTH)); 
            
            lines.push(formatSpacer()); // Blank line AFTER transition
            return lines;
        }

        // 4. Dialogue Block
        function formatDialogue(s) {
            const lines = [];
            const charName = s.content.toUpperCase();
            
            lines.push(formatSpacer()); // Blank line BEFORE dialogue (to be deduplicated by buffer)

            // Character Name Line
            const namePad = Math.max(0, DIALOGUE_COL + Math.floor((DIALOGUE_WIDTH - charName.length) / 2));
            let charLine = charName;

            let inlineElements = [];
            if (s.context) inlineElements.push(s.context);
            if (s.contd) inlineElements.push("CONT'D");
            if (inlineElements.length > 0) {
                charLine += " " + inlineElements.map(p => `(${p})`).join(' ');
            }
            lines.push(padString(charLine, namePad, CHAR_WIDTH));

            // Parenthetical Line
            const rawParentheticals = s.parenthetical ? s.parenthetical.split(',').map(p => p.trim()).filter(p => p.length > 0) : [];
            if (rawParentheticals.length > 0) {
                lines.push(padString(`(${rawParentheticals.join(' ')})`, PARENTHETICAL_COL, CHAR_WIDTH));
            }

            // Dialogue Text Lines
            const wrappedDialogue = wordWrap(s.text, DIALOGUE_WIDTH);
            wrappedDialogue.forEach(line => {
                lines.push(padString(line, DIALOGUE_COL, CHAR_WIDTH));
            });

            lines.push(formatSpacer()); // Blank line AFTER dialogue
            return lines;
        }

        // 5. Montage Item
        function formatMontageItem(item) {
            const lines = [];
            lines.push(padString(`-- ${item}`, 0, CHAR_WIDTH));
            return lines;
        }

        // 6. Title Card/Intertitle
        function formatTitleCard(text) {
            const lines = [];
            lines.push(formatSpacer()); // Blank line
            
            const centeredText = text.toUpperCase();
            const centerPad = Math.floor((CHAR_WIDTH - centeredText.length) / 2);
            lines.push(padString(centeredText, centerPad, CHAR_WIDTH));
            
            lines.push(formatSpacer()); // Blank line
            return lines;
        }


        // --- MAIN GENERATION FUNCTION ---

        function generateScript() {
            let scriptHtml = '';
            const buffer = new PageBuffer();

            // --- 1. TITLE PAGE ---
            // Title Page is treated separately because it doesn't follow fixed-pitch line rules.
            scriptHtml += `
                <div class="sc-title-page">
                    <h1 style="text-align: center; margin-top: 200px; font-size: 36pt;">${scriptMetadata.title || 'UNTITLED SCREENPLAY'}</h1>
                    ${scriptMetadata.author ? `<p style="text-align: center; margin-top: 100px;">Written by<br><b>${scriptMetadata.author}</b></p>` : ''}
                </div>
            `;

            // --- 2. GLOBAL TRANSITIONS ---
            scriptMetadata.transitions.forEach(t => {
                const lines = formatTransition(t);
                scriptHtml += buffer.insert(lines, 'sc-transition');
            });

            // --- 3. SCENES ---
            cards.forEach(c => {
                
                // Scene must start on a new page (Page break logic)
                scriptHtml += buffer.insert([], 'sc-break', true); 
                
                // 3a. SCENE HEADER
                const headerLines = formatHeader(`${c.sceneNumber}. ${c.header}`);
                scriptHtml += buffer.insert(headerLines, 'sc-header');

                // 3b. OPENING ACTION / NOTES
                if(c.notes) {
                    const actionLines = formatAction(c.notes);
                    scriptHtml += buffer.insert(actionLines, 'sc-action');
                }

                // 3c. MONTAGE ELEMENTS
                if (c.header.toUpperCase().startsWith('MONTAGE') && c.montage && c.montage.length > 0) {
                    c.montage.forEach(item => {
                        const lines = formatMontageItem(item);
                        scriptHtml += buffer.insert(lines, 'sc-montage-item');
                    });
                    // Add a blank line after the entire montage block
                    scriptHtml += buffer.insert([formatSpacer()], 'sc-action');
                } 
                
                // 3d. SEQUENCE ELEMENTS (Dialogue/Action)
                else {
                    c.sequence.forEach(s => {
                        let lines = [];
                        let cssClass = '';

                        if (s.type === 'Character') {
                            lines = formatDialogue(s);
                            cssClass = 'sc-dialog-block';
                        } else if (s.type === 'Action') {
                            const styleUpper = (s.style || '').toUpperCase();
                            
                            if (styleUpper === 'TITLE CARD' || styleUpper === 'INTERTITLE') {
                                lines = formatTitleCard(s.text);
                                cssClass = 'sc-intertitle';
                            } else if (ALL_TRANSITIONS_AND_ACTIONS.includes(styleUpper) && styleUpper !== '' ) {
                                let text = s.text.trim();
                                // Action text before transition (if any)
                                if (text) { scriptHtml += buffer.insert(formatAction(text), 'sc-action'); }
                                
                                lines = formatTransition(styleUpper);
                                cssClass = 'sc-transition';
                            } else {
                                lines = formatAction(s.text);
                                cssClass = 'sc-action';
                            }
                        }
                        
                        if (lines.length > 0) {
                            scriptHtml += buffer.insert(lines, cssClass);
                        }
                    });
                }
                
                // 3e. FINAL TRANSITIONS from TAGS
                const finalTags = c.tags.split(',').filter(t => t.trim().toUpperCase().includes('FADE OUT') || t.trim().toUpperCase().includes('CUT TO') || t.trim().toUpperCase().includes('DISSOLVE TO'));
                finalTags.forEach(t => {
                    const lines = formatTransition(t);
                    scriptHtml += buffer.insert(lines, 'sc-transition');
                });

            });

            // Flush any remaining lines on the last page
            scriptHtml += buffer.flush(); 

            document.getElementById('script-content').innerHTML = scriptHtml;
        }


        // --- STATS & CHARACTER MANAGEMENT UI ---
        function showStats() {
            let intC=0, extC=0, dayC=0, nightC=0;
            cards.forEach(c => {
                const h = c.header.toUpperCase();
                if(h.includes('INT')) intC++; if(h.includes('EXT')) extC++;
                if(h.includes('DAY')) dayC++; if(h.includes('NIGHT')) nightC++;
            });
            const tot = cards.length || 1; 
            const totalTime = calculateTotalScriptTime(); 
            
            const characterStats = {};

            cards.forEach(c => {
                const sceneTime = estimateScreenTime(c);
                
                c.sequence.forEach(s => {
                    if (s.type === 'Character' && s.content) {
                        const finalName = resolveCharacterName(s.content);
                        
                        if (!characterStats[finalName]) {
                            characterStats[finalName] = { lines: 0, wordCount: 0, scenes: new Set(), totalTime: 0 };
                        }
                        
                        characterStats[finalName].lines += 1;
                        characterStats[finalName].wordCount += countWords(s.text);
                        characterStats[finalName].scenes.add(c.id);
                        characterStats[finalName].totalTime += sceneTime;
                    }
                });
            });

            const sortedChars = Object.entries(characterStats).sort(([, a], [, b]) => b.lines - a.lines);
            
            let statsHtml = `
                <div class="stat-row total-time-stat">
                    <div>Total Run Time:</div>
                    <div>${totalTime} min</div>
                </div>
                <h3 style="margin-top:20px; margin-bottom: 5px;">Scene Counts (${tot} scenes)</h3>
                <div class="stat-row"><div>Interior: ${intC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${(intC/tot)*100}%"></div></div></div>
                <div class="stat-row"><div>Exterior: ${extC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${(extC/tot)*100}%"></div></div></div>
                <hr>
                <div class="stat-row"><div>Day: ${dayC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="background:#f1c40f;width:${(dayC/tot)*100}%"></div></div></div>
                <div class="stat-row"><div>Night: ${nightC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="background:#8e44ad;width:${(nightC/tot)*100}%"></div></div></div>
                <h3 style="margin-top:20px; margin-bottom: 5px;">Character Stats (Resolved)</h3>
            `;
            
            sortedChars.forEach(([name, stats]) => {
                const description = scriptMetadata.characterProxies[name]?.description || '';
                const scenesParticipated = stats.scenes.size;
                const maxLines = sortedChars[0][1].lines || 1; 

                statsHtml += `
                    <div style="margin-top: 15px; border-top: 1px solid var(--border); padding-top: 10px;">
                        <strong>${name} (${stats.lines} lines, ${scenesParticipated} scenes)</strong>
                        <small style="display: block; opacity: 0.7;">${description}</small>
                        <div class="stat-bar-bg" style="margin-top: 5px;">
                            <div class="stat-bar-fill" style="width:${(stats.lines/maxLines)*100}%; background: #e74c3c;"></div>
                        </div>
                    </div>
                `;
            });

            document.getElementById('stats-content').innerHTML = statsHtml;
            document.getElementById('stats-modal').style.display = 'flex';
        }
        
        function showCharacterManagement() {
            updateCharacterList(); 
            renderCharacterTable();
            document.getElementById('char-modal').style.display = 'flex';
        }

        function renderCharacterTable() {
            const tbody = document.getElementById('charManagementBody');
            tbody.innerHTML = '';
            
            const allCharNames = getAllCharacterNames();
            
            // --- FIXED PROXY LOGIC ---
            const allUniqueNames = new Set(allCharNames);
            Object.values(scriptMetadata.characterProxies).forEach(p => allUniqueNames.add(p.proxyFor));
            const primaryCharacters = Array.from(allUniqueNames).sort();
            // --------------------------


            allCharNames.forEach(name => {
                const charData = scriptMetadata.characterProxies[name] || { proxyFor: name, description: '' };
                const isProxy = charData.proxyFor !== name;

                const proxyOptions = primaryCharacters.map(p => 
                    `<option value="${p}" ${p === charData.proxyFor ? 'selected' : ''}>${p}</option>`
                ).join('');
                
                const descriptionValue = charData.description || '';
                
                tbody.innerHTML += `
                    <tr>
                        <td style="padding: 8px 0;">
                            <strong>${name}</strong>
                            ${isProxy ? '<span style="color: green; font-size: 0.8em;"> (PROXY)</span>' : ''}
                        </td>
                        <td style="padding: 8px 0;">
                            <select onchange="updateCharacterProxy('${name}', this.value)" ${isProxy ? 'style="border: 1px solid green;"' : ''}>
                                ${proxyOptions}
                            </select>
                        </td>
                        <td style="padding: 8px 0;">
                            <input type="text" value="${descriptionValue}" placeholder="Description/Notes" oninput="updateCharacterDescription('${name}', this.value)" ${isProxy ? 'disabled' : ''}>
                        </td>
                    </tr>
                `;
            });
        }

        function updateCharacterProxy(name, proxyFor) {
            if (scriptMetadata.characterProxies[name]) {
                scriptMetadata.characterProxies[name].proxyFor = proxyFor;
                saveData();
                renderCharacterTable(); 
            }
        }

        function updateCharacterDescription(name, description) {
            if (scriptMetadata.characterProxies[name]) {
                scriptMetadata.characterProxies[name].description = description;
                saveData();
            }
        }
        
        function handleSearch(val) { currentSearchTerm = val.toLowerCase(); renderList(); }
        
        
        // --- METADATA FUNCTIONS ---
        
        function showMetadataEditor() {
            document.getElementById('meta-title').value = scriptMetadata.title;
            document.getElementById('meta-author').value = scriptMetadata.author;
            renderGlobalTransitions();
            document.getElementById('metadata-modal').style.display = 'flex';
        }

        function updateMetadata(field, value) {
            scriptMetadata[field] = value;
            saveData();
        }

        function renderGlobalTransitions() {
            const list = document.getElementById('globalTransitionList');
            list.innerHTML = '';
            
            scriptMetadata.transitions.forEach((t, i) => {
                const li = document.createElement('li');
                li.style.cssText = 'padding: 8px 0; border-bottom: 1px solid var(--border); display: flex; align-items: center;';
                
                li.innerHTML = `
                    <input type="text" value="${t}" style="flex-grow: 1; border: none; background: transparent; padding: 0 8px;" 
                        oninput="updGlobalTransition(${i}, this.value)">
                    <button onclick="delGlobalTransition(${i})" style="color: #e74c3c; background: none; border: none; cursor: pointer; padding: 5px;">Delete</button>
                `;
                list.appendChild(li);
            });
        }

        function addGlobalTransition() {
            const newTransition = 'FADE IN:';
            scriptMetadata.transitions.push(newTransition);
            saveData();
            renderGlobalTransitions();
        }

        function updGlobalTransition(i, v) { 
            scriptMetadata.transitions[i] = v.toUpperCase().trim(); 
            saveData(); 
            renderGlobalTransitions(); 
        }

        function delGlobalTransition(i) { 
            scriptMetadata.transitions.splice(i, 1); 
            saveData(); 
            renderGlobalTransitions(); 
        }
    </script>
</body>
</html>

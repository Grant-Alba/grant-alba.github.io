<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SceneCard Writer v6.4 (Structured Dialogue Tags)</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root { 
            --bg: #f4f4f9; --sidebar: #2c3e50; --text: #333; 
            --accent: #3498db; --border: #ddd; --card-bg: #fff;
            --input-bg: #fff; --sb-tool: #34495e;
            --action-bg: #f0f8ff; /* Light blue for action rows */
        }
        
        /* Dark Mode Overrides */
        body.dark-mode {
            --bg: #1e1e1e; --sidebar: #151515; --text: #ecf0f1; 
            --border: #444; --card-bg: #2c2c2c; 
            --input-bg: #333; --sb-tool: #252525;
            --action-bg: #3b3b4d; /* Darker blue/gray for action rows */
        }

        body { margin: 0; font-family: system-ui, -apple-system, sans-serif; display: flex; height: 100vh; background: var(--bg); color: var(--text); overflow: hidden; transition: background 0.3s; }
        
        /* --- LAYOUT --- */
        #sidebar { width: 300px; background: var(--sidebar); color: white; display: flex; flex-direction: column; border-right: 1px solid #1a252f; flex-shrink: 0; transition: width 0.3s; }
        #main { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; position: relative; }
        
        /* --- SIDEBAR COMPONENTS --- */
        .brand { padding: 15px; font-size: 1.1rem; font-weight: bold; background: rgba(0,0,0,0.2); display: flex; justify-content: space-between; align-items: center; }
        .theme-toggle { cursor: pointer; background: none; border: none; font-size: 1.2rem; }

        .tools { padding: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .tool-btn { background: var(--sb-tool); color: white; border: 1px solid #46637f; padding: 6px; cursor: pointer; font-size: 0.75rem; border-radius: 4px; }
        .tool-btn:hover { background: #3e5871; }

        #search-input {
            width: 90%; margin: 10px auto; padding: 8px 10px;
            background: var(--sb-tool); border: 1px solid #46637f;
            color: white; border-radius: 4px; display: block; box-sizing: border-box;
        }

        .add-btn { padding: 15px; background: #27ae60; color: white; border: none; cursor: pointer; font-weight: bold; border-bottom: 1px solid #1e8449; }
        .add-btn:hover { background: #2ecc71; }

        .card-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex: 1; }
        .card-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); cursor: pointer; font-size: 0.9rem; border-left: 6px solid #555; }
        .card-item.active { background: rgba(255,255,255,0.1); border-right: 4px solid var(--accent); }
        
        /* Color Coding */
        .card-item.scene-int, .board-card.scene-int { border-left-color: #3498db; }
        .card-item.scene-ext, .board-card.scene-ext { border-left-color: #2ecc71; }
        .card-item.scene-montage, .board-card.scene-montage { border-left-color: #9b59b6; } 

        /* --- EDITOR VIEW --- */
        .editor-card { background: var(--card-bg); padding: 30px; border-radius: 8px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 0.75rem; text-transform: uppercase; color: #7f8c8d; }
        input, textarea { width: 100%; padding: 10px; border: 1px solid var(--border); background: var(--input-bg); color: var(--text); border-radius: 4px; box-sizing: border-box; }
        
        /* SEQUENCE TABLE */
        table.sequence-table { width: 100%; border-collapse: collapse; margin-top: 5px; }
        table.sequence-table th { text-align: left; background: rgba(0,0,0,0.05); padding: 8px; font-size: 0.75rem; color: #7f8c8d; }
        
        table.sequence-table td { padding: 0; }
        
        .row-character { border-bottom: 1px solid var(--border); }
        .row-action { background: var(--action-bg); border-bottom: 1px solid var(--border); }

        /* Custom cell for Dialogue context/contd controls */
        .col-dialog-controls {
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 5px;
            font-size: 0.8em;
        }
        .col-dialog-controls select {
            padding: 5px;
            border: 1px solid var(--border);
            background: var(--input-bg);
        }
        .contd-checkbox {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .sequence-input { border: none; background: transparent; padding: 8px; border-bottom: 1px solid transparent; width: 100%; box-sizing: border-box; }
        .sequence-input:focus { border-bottom: 1px solid var(--accent); outline: none; }

        .col-content textarea { 
            width: 100%; min-height: 50px; resize: vertical; border: none; 
            border-radius: 0; background: transparent; padding: 8px; box-sizing: border-box; 
            font-family: inherit; color: inherit;
        }
        .col-content textarea:focus { border-bottom: 1px solid var(--accent); outline: none; }
        
        .col-del { cursor: pointer; color: #e74c3c; text-align: center; }
        .col-add { cursor: pointer; color: #2ecc71; text-align: center; font-size: 1.2rem; }
        
        /* SCRIPT VIEW */
        #script-content { 
            background: white; padding: 60px 80px; max-width: 800px; margin: 0 auto; min-height: 100%;
            font-family: 'Courier Prime', 'Courier New', monospace; font-size: 12pt; color: black; box-shadow: 0 0 20px rgba(0,0,0,0.2); 
            line-height: 1.2em;
        }
        .sc-header { margin-top: 1.5em; margin-bottom: 1em; text-transform: uppercase; }
        .sc-action { margin-top: 1em; margin-bottom: 1em; } 
        
        /* Character and Dialogue Formatting */
        .sc-character-block { 
            /* FIX: Use flex to center and keep name and inline tags together */
            display: flex; 
            justify-content: center; 
            align-items: center; 
            margin-top: 1em; 
            margin-bottom: 0.2em; 
            margin-left: 3.5in; 
            margin-right: 3.5in;
        } 
        .sc-character { text-transform: uppercase; white-space: nowrap; } 
        
        /* Parentheticals that stay on the name line (V.O., CONT'D) */
        .sc-parenthetical-inline { 
            margin-left: 0.2em; 
            font-style: italic; 
            white-space: nowrap; 
        } 
        
        /* Parenthetical line (e.g., stage direction like (turning)) */
        .sc-parenthetical-line { 
            text-align: center; 
            margin-left: 2.75in; 
            margin-right: 2.75in;
            margin-top: 0.2em;
            margin-bottom: 0.2em;
            font-style: italic;
        }
        
        .sc-dialog { margin-left: 1.5in; margin-right: 1.5in; margin-top: 0.5em; margin-bottom: 0.5em; white-space: pre-wrap; } 

        .sc-intertitle { text-align: center; margin: 3em 0; font-weight: bold; font-size: 14pt; } 
        .sc-action-inline { margin-top: 1em; margin-bottom: 1em; font-style: italic; } 
        
        /* UTILS */
        .hidden { display: none !important; }

        /* VIEW CONTAINER VISIBILITY FIX */
        .view-container { display: none; }
        .view-container.visible { display: block; }
        
        /* STATS MODAL STYLES */
        #stats-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .stats-box {
            background: var(--card-bg); padding: 30px; border-radius: 8px; width: 350px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); color: var(--text);
        }
        .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .stat-bar-bg { flex-grow: 1; height: 10px; background: var(--border); margin-left: 10px; border-radius: 5px; }
        .stat-bar-fill { height: 100%; background: var(--accent); border-radius: 5px; transition: width 0.5s; }
    </style>
</head>
<body>

    <datalist id="character-list"></datalist>

    <div id="sidebar">
        <div class="brand">
            <span>üé¨ ScreenCard</span>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Dark Mode">üåì</button>
        </div>
        <div class="tools">
            <button class="tool-btn" onclick="saveJSON()">üíæ Save .JSON</button>
            <button class="tool-btn" onclick="document.getElementById('file-input').click()">üìÇ Load File</button>
            <button class="tool-btn" onclick="downloadFountain()">üìÑ Exp. Fountain</button>
            <button class="tool-btn" onclick="showStats()">üìä Stats</button>
            <button class="tool-btn" onclick="switchView('storyboard')">üìå Board</button>
            <button class="tool-btn" onclick="switchView('script')">üñ®Ô∏è Script View</button>
            <input type="file" id="file-input" accept=".json,.fountain,.txt" class="hidden" onchange="handleFileUpload(this)">
        </div>
        
        <input type="text" id="search-input" placeholder="üîç Filter scenes..." oninput="handleSearch(this.value)">
        <button class="add-btn" onclick="addNewCard()">+ New Scene</button>
        
        <ul class="card-list" id="cardList"></ul>
    </div>

    <div id="main">
        
        <div id="editor-view" class="view-container visible">
            <div id="empty-state" style="text-align: center; opacity: 0.5; margin-top: 100px;">
                <h3>Select or Create a Scene</h3>
            </div>
            
            <div id="editor" class="editor-card hidden">
                <div class="field-group">
                    <label>Scene Header</label>
                    <input type="text" id="inp-header" placeholder="EXT. LOCATION - TIME or MONTAGE - TYPE" oninput="updateHeader(this.value);">
                </div>
                <div class="field-group">
                    <label>Location (Auto-Extracted)</label>
                    <input type="text" id="inp-location" placeholder="POLICE STATION" oninput="updateCurrentCard('location', this.value);">
                </div>

                <div class="meta-grid" style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                    <div class="field-group">
                        <label>Characters</label>
                        <input type="text" id="inp-chars" list="character-list" placeholder="Bubba, Sheriff..." oninput="updateCurrentCard('chars', this.value)">
                    </div>
                    <div class="field-group">
                        <label>Props</label>
                        <input type="text" id="inp-props" placeholder="Red Car..." oninput="updateCurrentCard('props', this.value)">
                    </div>
                </div>
                <div class="field-group">
                    <label>Opening Action / Scene Notes</label>
                    <textarea rows="4" id="inp-notes" placeholder="Describe initial action..." oninput="updateCurrentCard('notes', this.value)"></textarea>
                </div>
                <div class="field-group">
                    <label>Tags</label>
                    <input type="text" id="inp-tags" placeholder="Flashback, Montage..." oninput="updateCurrentCard('tags', this.value)">
                </div>
                <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">

                <div id="montage-editor-block" class="hidden">
                    <label>Montage Elements (Drag to reorder)</label>
                    <ul id="montageList" style="list-style: none; padding: 0; margin: 5px 0;"></ul>
                    <button onclick="addMontageItem()" style="margin-top:10px; cursor:pointer;">+ Add Montage Item</button>
                    <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">
                </div>
                
                <div id="sequence-editor-block">
                    <label>Dialogue and Inter-Dialogue Action Sequence</label>
                    <table class="sequence-table">
                        <thead><tr><th width="25%">Character</th><th width="25%">Context / Continuation</th><th width="40%">Parenthetical / Content</th><th width="5%"></th></tr></thead>
                        <tbody id="sequenceBody"></tbody>
                    </table>
                    <button onclick="addSequenceItem('Character')" style="margin-top:10px; cursor:pointer;">+ Add Dialogue Line</button>
                    <button onclick="addSequenceItem('Action')" style="margin-top:10px; cursor:pointer;">+ Add Action Block</button>
                </div>

                <button onclick="deleteCurrentCard()" style="float:right; margin-top:10px; color:red; cursor:pointer;">Delete</button>
            </div>
        </div>

        <div id="storyboard-view" class="view-container">
            <div class="board-grid" id="boardGrid"></div>
        </div>

        <div id="script-view" class="view-container">
            <div id="script-content"></div>
            <button onclick="window.print()" style="position:fixed; bottom:20px; right:20px; padding:10px 20px; background:#27ae60; color:white; border:none; cursor:pointer;">Print PDF</button>
        </div>
    </div>

    <div id="stats-modal" onclick="this.style.display='none'">
        <div class="stats-box" onclick="event.stopPropagation()">
            <h2 style="margin-top:0">Script Statistics</h2>
            <div id="stats-content"></div>
            <button onclick="document.getElementById('stats-modal').style.display='none'" style="width:100%; margin-top:20px; padding:10px;">Close</button>
        </div>
    </div>

    <script>
        // --- STATE ---
        let cards = [];
        // UPDATED: Added 'location' field
        const EMPTY_CARD = { id: Date.now(), header: 'INT. NEW SCENE - DAY', location: 'NEW SCENE', chars: '', props: '', notes: '', tags: '', sequence: [], montage: [] };
        let scriptMetadata = { title: 'UNTITLED SCREENPLAY', author: '', transitions: [] }; 
        let activeCardId = null;
        let dragStartIndex;
        let currentSearchTerm = '';
        let currentView = 'editor'; 

        // --- INIT ---
        window.onload = () => {
            const saved = localStorage.getItem('screenplayData');
            const savedMeta = localStorage.getItem('scriptMetadata');
            const theme = localStorage.getItem('theme');
            if (saved) {
                cards = JSON.parse(saved);
                // Migration logic: Map old 'style' field to new structured fields and rename 'style' to 'parenthetical'
                cards.forEach(card => {
                    if (card.dialog && !card.sequence) {
                        // Migration for old Dialogue array to Sequence
                        card.sequence = card.dialog.map(d => ({ 
                            type: 'Character', content: d.character, text: d.text, 
                            context: '', contd: false, parenthetical: ''
                        }));
                        delete card.dialog;
                    }
                    
                    card.sequence.forEach(s => {
                        if (s.type === 'Character') {
                            // Run the new migration logic for dialogue fields
                            migrateDialogueFields(s);
                        }
                    });

                    // Ensure new fields exist on all cards/items for clean loading
                    if (!card.location) { card.location = extractLocation(card.header); }
                });
            }
            if (savedMeta) scriptMetadata = JSON.parse(savedMeta);
            if (theme === 'dark') document.body.classList.add('dark-mode');
            updateCharacterList();
            renderList();
        };

        function migrateDialogueFields(s) {
            // Check for older data structures and initialize new fields
            if (!s.context) s.context = '';
            if (s.contd === undefined) s.contd = false;

            // Migration from old combined 'style' field to new structured fields
            if (s.style !== undefined && s.type === 'Character') {
                const parts = s.style.split(',').map(p => p.trim().toUpperCase());
                let parentheticals = [];

                parts.forEach(p => {
                    if (p === 'V.O.') {
                        s.context = 'V.O.';
                    } else if (p === 'O.S.') {
                        s.context = 'O.S.';
                    } else if (p === 'CONT\'D' || p === 'CONT\'D.') {
                        s.contd = true;
                    } else if (p.length > 0) {
                        // If it's none of the above, it's a parenthetical action/tone
                        parentheticals.push(p);
                    }
                });

                // Rename and assign the cleaned up parenthetical content
                s.parenthetical = parentheticals.join(', ');
                delete s.style; // Remove old field
            } 
            
            // If the old field was already renamed, ensure 'parenthetical' exists
            if (s.parenthetical === undefined && s.style === undefined) {
                s.parenthetical = '';
            }
        }

        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }

        function switchView(viewName) {
            currentView = viewName;
            
            // 1. Hide all view containers and set correct sidebar visibility
            document.querySelectorAll('.view-container').forEach(el => el.classList.remove('visible'));
            document.getElementById('sidebar').style.display = (viewName === 'editor') ? 'flex' : 'none';
            
            // 2. Show the relevant view and run its specific renderer
            if (viewName === 'editor') { 
                document.getElementById('editor-view').classList.add('visible'); 
                // Only call loadEditor if an ID is active, to prevent showing partial content
                if (activeCardId) loadEditor(activeCardId, false);
                renderList(); 
            }
            else if (viewName === 'storyboard') { 
                document.getElementById('storyboard-view').classList.add('visible'); 
                renderStoryboard(); 
            }
            else if (viewName === 'script') { 
                document.getElementById('script-view').classList.add('visible'); 
                generateScript(); 
            }
        }

        // --- LOCATION EXTRACTION LOGIC ---
        function extractLocation(header) {
            if (!header) return '';
            const upperHeader = header.toUpperCase().trim();
            const parts = upperHeader.split(' - ');

            if (upperHeader.startsWith('MONTAGE')) {
                return upperHeader;
            }

            if (parts.length >= 2) {
                let locationPart = parts[0];
                
                const prefixRegex = /^(INT|EXT|I\/E|INT\/EXT|EST|I\/E)\.\s*/;
                locationPart = locationPart.replace(prefixRegex, '').trim();
                
                return locationPart;
            } else if (parts.length === 1) {
                const prefixRegex = /^(INT|EXT|I\/E|INT\/EXT|EST|I\/E)\.\s*/;
                return upperHeader.replace(prefixRegex, '').trim();
            }

            return upperHeader;
        }

        function updateHeader(value) {
            // 1. Update the header field in the data model
            updateCurrentCard('header', value);

            // 2. Extract and update the location field
            const location = extractLocation(value);
            updateCurrentCard('location', location);
            document.getElementById('inp-location').value = location;

            // 3. Handle Montage block visibility
            toggleMontageEditor(value);
        }
        
        // --- CORE DATA ---
        function addNewCard() {
            const newCard = { ...EMPTY_CARD, id: Date.now() }; 
            newCard.location = extractLocation(newCard.header); 

            cards.push(newCard);
            activeCardId = newCard.id;
            
            switchView('editor'); 
            saveData(); 
            loadEditor(newCard.id);
        }

        function saveData() {
            localStorage.setItem('screenplayData', JSON.stringify(cards));
            localStorage.setItem('scriptMetadata', JSON.stringify(scriptMetadata));
            updateCharacterList();
            if(currentView === 'editor') renderList();
        }

        function updateCurrentCard(field, value) {
            const card = cards.find(c => c.id === activeCardId);
            if(card) { card[field] = value; saveData(); }
        }

        function updateCharacterList() {
            const charSet = new Set();
            cards.forEach(c => {
                c.chars.split(',').forEach(n => { if(n.trim()) charSet.add(n.trim()); });
                c.sequence && c.sequence.forEach(s => { 
                    if (s.type === 'Character' && s.content.trim()) charSet.add(s.content.trim()); 
                });
            });
            const dl = document.getElementById('character-list');
            dl.innerHTML = '';
            charSet.forEach(char => { let opt = document.createElement('option'); opt.value = char; dl.appendChild(opt); });
        }

        // --- EDITOR UI ---
        function loadEditor(id) {
            activeCardId = id;
            const card = cards.find(c => c.id === id);
            
            if (!card) {
                document.getElementById('editor').classList.add('hidden');
                document.getElementById('empty-state').classList.remove('hidden');
                return;
            }

            document.getElementById('empty-state').classList.add('hidden');
            document.getElementById('editor').classList.remove('hidden');
            ['header', 'location', 'chars', 'props', 'notes', 'tags'].forEach(f => document.getElementById('inp-' + f).value = card[f]);
            
            toggleMontageEditor(card.header); 
            
            if (card.header.toUpperCase().startsWith('MONTAGE')) {
                renderMontageList(card.montage || []);
            } else {
                renderSequenceTable(card.sequence || []);
            }
            
            renderList();
        }

        // Sequence Rendering 
        function renderSequenceTable(sequence) {
            const tbody = document.getElementById('sequenceBody');
            tbody.innerHTML = '';
            
            if (!sequence) return;

            // The header changes based on the first column for actions
            const actionHeader = `<tr><th width="25%">Character</th><th width="25%">Context / Continuation</th><th width="40%">Parenthetical / Content</th><th width="5%"></th></tr>`;
            const actionHeaderSimplified = `<tr><th width="25%">Character/Action</th><th width="15%">Style/Type</th><th>Content</th><th width="5%"></th></tr>`;

            sequence.forEach((item, i) => {
                let actionStyleLabel = 'Action';
                
                if (item.type === 'Character') {
                    // --- CHARACTER ROW (Character Name, Context, Cont'd, Parenthetical, Dialogue) ---
                    // Ensure migration is run just in case this item was created pre-v6.4
                    migrateDialogueFields(item); 
                    
                    // Display Context and Cont'd fields 
                    const contextSelect = `
                        <select onchange="updSeq(${i}, 'context', this.value)">
                            <option value="" ${item.context === '' ? 'selected' : ''}></option>
                            <option value="V.O." ${item.context === 'V.O.' ? 'selected' : ''}>V.O.</option>
                            <option value="O.S." ${item.context === 'O.S.' ? 'selected' : ''}>O.S.</option>
                        </select>`;
                        
                    const contdCheckbox = `
                        <label class="contd-checkbox">
                            <input type="checkbox" ${item.contd ? 'checked' : ''} onchange="updSeq(${i}, 'contd', this.checked)"> 
                            CONT'D
                        </label>`;
                        
                    tbody.innerHTML += `<tr class="row-character" draggable="true" data-index="${i}" ondragstart="startDragSequence(event)" ondragover="dragOverSequence(event)" ondrop="dropSequence(event)">
                        <td>
                            <input list="character-list" class="sequence-input" value="${item.content || ''}" oninput="updSeq(${i}, 'content', this.value)">
                        </td>
                        <td class="col-dialog-controls">
                            ${contextSelect}
                            ${contdCheckbox}
                        </td>
                        <td class="col-content">
                            <input class="sequence-input" placeholder="(parenthetical action)" value="${item.parenthetical || ''}" oninput="updSeq(${i}, 'parenthetical', this.value)">
                            <textarea rows="3" placeholder="Dialogue..." oninput="updSeq(${i}, 'text', this.value)">${item.text || ''}</textarea>
                        </td>
                        <td class="col-del" onclick="delSeq(${i})">√ó</td>
                    </tr>`;
                } else if (item.type === 'Action') {
                    // Action items use the old format (Style/Type for things like TITLE CARD, and Content for text)
                    const styleUpper = (item.style || '').toUpperCase();
                    if (styleUpper === 'TITLE CARD' || styleUpper === 'INTERTITLE') actionStyleLabel = styleUpper;
                    
                    // --- ACTION ROW (Fixed Label, Editable Style, Action Text) ---
                    tbody.innerHTML += `<tr class="row-action" draggable="true" data-index="${i}" ondragstart="startDragSequence(event)" ondragover="dragOverSequence(event)" ondrop="dropSequence(event)">
                        <td style="color: #7f8c8d; font-size: 0.8em; font-style: italic;">${actionStyleLabel}</td>
                        <td>
                            <input class="sequence-input" placeholder="Action Style (e.g., V.O., TITLE CARD)" value="${item.style || ''}" oninput="updSeq(${i}, 'style', this.value)">
                        </td>
                        <td class="col-content">
                            <textarea rows="2" placeholder="Action between lines..." oninput="updSeq(${i}, 'content', this.value)">${item.content || ''}</textarea>
                        </td>
                        <td class="col-del" onclick="delSeq(${i})">√ó</td>
                    </tr>`;
                }
            });
        }
        
        function startDragSequence(event) {
            dragStartIndex = +event.target.closest('tr').dataset.index;
            event.dataTransfer.setData('text/plain', dragStartIndex);
            event.target.closest('tr').style.opacity = '0.4';
        }

        function dragOverSequence(event) {
            event.preventDefault();
            event.target.closest('tr').style.borderTop = '2px solid var(--accent)';
        }
        
        function dropSequence(event) {
            event.preventDefault();
            const fromIndex = dragStartIndex;
            const toIndex = +event.target.closest('tr').dataset.index;
            event.target.closest('tr').style.opacity = '1';
            event.target.closest('tr').style.borderTop = '';

            if (fromIndex !== toIndex) {
                const sequence = cards.find(c => c.id === activeCardId).sequence;
                const item = sequence[fromIndex];
                sequence.splice(fromIndex, 1);
                sequence.splice(toIndex, 0, item);
                saveData();
                renderSequenceTable(sequence);
            }
        }

        function updSeq(i, f, v) { 
            const item = cards.find(c => c.id === activeCardId).sequence[i];
            
            // Handle Character fields
            if (f === 'content' || f === 'text' || f === 'parenthetical' || f === 'context') {
                item[f] = v;
            } else if (f === 'contd') { 
                item.contd = v; // Checkbox value is a boolean
            }
            
            // Handle Action fields (retains old naming for backward compatibility with Action type)
            else if (f === 'style' && item.type === 'Action') {
                item.style = v;
            }

            saveData(); 
        }

        function addSequenceItem(type, index = null) { 
            const card = cards.find(c => c.id === activeCardId);
            const newItem = type === 'Character' 
                ? { type: 'Character', content: '', context: '', contd: false, parenthetical: '', text: '' }
                : { type: 'Action', content: '', style: '' }; 
            
            if (index !== null) {
                card.sequence.splice(index, 0, newItem);
            } else {
                card.sequence.push(newItem);
            }
            
            saveData(); 
            renderSequenceTable(card.sequence); 
        }

        function delSeq(i) { 
            cards.find(c => c.id === activeCardId).sequence.splice(i, 1); 
            saveData(); 
            renderSequenceTable(cards.find(c => c.id === activeCardId).sequence); 
        }

        function deleteCurrentCard() { 
            if(confirm("Delete scene?")) { 
                cards = cards.filter(c => c.id !== activeCardId); 
                activeCardId = null; 
                document.getElementById('editor').classList.add('hidden'); 
                document.getElementById('empty-state').classList.remove('hidden');
                saveData(); 
            } 
        }


        // --- MONTAGE UI AND LOGIC ---
        function toggleMontageEditor(header) {
            const isMontage = (header || document.getElementById('inp-header').value).toUpperCase().startsWith('MONTAGE');
            document.getElementById('montage-editor-block').classList.toggle('hidden', !isMontage);
            document.getElementById('sequence-editor-block').classList.toggle('hidden', isMontage);
            
            const currentCard = cards.find(c => c.id === activeCardId);
            if (!currentCard) return;

            if (isMontage) {
                if (currentCard.sequence && currentCard.sequence.length > 0) { currentCard.sequence = []; renderSequenceTable([]); }
            } else {
                if (currentCard.montage && currentCard.montage.length > 0) { currentCard.montage = []; renderMontageList([]); }
            }
        }

        function renderMontageList(montage) {
            const list = document.getElementById('montageList');
            list.innerHTML = '';
            montage.forEach((item, i) => {
                const li = document.createElement('li');
                li.style.cssText = 'padding: 8px 0; border-bottom: 1px solid var(--border); display: flex; align-items: center; cursor: grab;';
                li.dataset.index = i;
                li.draggable = true;
                
                li.innerHTML = `
                    <span style="margin-right: 10px; cursor: move;">::</span>
                    <input type="text" value="${item}" style="flex-grow: 1; border: none; background: transparent; padding: 0 8px;" oninput="updMontageItem(${i}, this.value)">
                    <button onclick="delMontageItem(${i})" style="color: #e74c3c; background: none; border: none; cursor: pointer; padding: 5px;">Delete</button>
                `;
                list.appendChild(li);

                // Add drag events for reordering
                li.addEventListener('dragstart', function() { dragStartIndex = +this.dataset.index; this.style.opacity = '0.4'; });
                li.addEventListener('dragover', function(e) { e.preventDefault(); });
                li.addEventListener('dragenter', function() { this.style.backgroundColor = 'rgba(52, 152, 219, 0.1)'; });
                li.addEventListener('dragleave', function() { this.style.backgroundColor = 'transparent'; });
                li.addEventListener('drop', function() { swapMontageItems(dragStartIndex, +this.dataset.index); this.style.opacity = '1'; this.style.backgroundColor = 'transparent'; });
                li.addEventListener('dragend', function() { this.style.opacity = '1'; });
            });
        }

        function updMontageItem(i, v) { cards.find(c => c.id === activeCardId).montage[i] = v; saveData(); }
        function addMontageItem() { cards.find(c => c.id === activeCardId).montage.push(''); saveData(); renderMontageList(cards.find(c => c.id === activeCardId).montage); }
        function delMontageItem(i) { cards.find(c => c.id === activeCardId).montage.splice(i, 1); saveData(); renderMontageList(cards.find(c => c.id === activeCardId).montage); }
        function swapMontageItems(fromIndex, toIndex) {
            const montage = cards.find(c => c.id === activeCardId).montage;
            const item = montage[fromIndex];
            montage.splice(fromIndex, 1);
            montage.splice(toIndex, 0, item);
            saveData();
            renderMontageList(montage);
        }

        // --- RENDERING LISTS ---
        function getColorClass(h) {
            h = (h || '').toUpperCase();
            if(h.startsWith('MONTAGE')) return 'scene-montage';
            if(h.includes('INT') && h.includes('EXT')) return 'scene-mix';
            if(h.startsWith('INT')) return 'scene-int';
            if(h.startsWith('EXT')) return 'scene-ext';
            return '';
        }

        function renderList() {
            const list = document.getElementById('cardList');
            list.innerHTML = '';
            cards.forEach((card, idx) => {
                const search = `${card.header} ${card.chars} ${card.tags} ${card.notes} ${card.location}`.toLowerCase();
                if(currentSearchTerm && !search.includes(currentSearchTerm)) return;
                const li = document.createElement('li');
                li.className = `card-item ${getColorClass(card.header)} ${card.id === activeCardId ? 'active' : ''}`;
                li.innerHTML = `<strong>${card.header}</strong><br><small>${card.location || ''} | ${card.tags || ''}</small>`;
                li.onclick = () => { switchView('editor'); loadEditor(card.id); };
                if(!currentSearchTerm) { li.draggable = true; li.dataset.index = idx; addDragEvents(li); }
                list.appendChild(li);
            });
        }

        function addDragEvents(el) {
            el.addEventListener('dragstart', function() { dragStartIndex = +this.dataset.index; this.style.opacity = '0.4'; });
            el.addEventListener('dragover', function(e) { e.preventDefault(); });
            el.addEventListener('dragenter', function() { this.classList.add('over'); });
            el.addEventListener('dragleave', function() { this.classList.remove('over'); });
            el.addEventListener('drop', function() { swapItems(dragStartIndex, +this.dataset.index); this.classList.remove('over'); this.style.opacity = '1'; });
        }
        function swapItems(f, t) { const i = cards[f]; cards.splice(f, 1); cards.splice(t, 0, i); saveData(); if(currentView==='editor') renderList(); else renderStoryboard(); }

        // --- STORYBOARD RENDERING (same as before) ---
        function renderStoryboard() {
            const grid = document.getElementById('boardGrid');
            grid.innerHTML = '';
            grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; padding: 10px;';
            
            cards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `board-card ${getColorClass(card.header)}`;
                div.style.cssText = 'background: var(--card-bg); padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-left: 6px solid; min-height: 150px; position: relative; cursor: pointer;';
                div.innerHTML = `
                    <div style="font-size: 0.8em; opacity: 0.6; margin-bottom: 5px;">#${idx + 1}</div>
                    <strong style="display: block; margin-bottom: 5px;">${card.header}</strong>
                    <p style="font-size: 0.9em; margin: 0 0 10px 0; max-height: 50px; overflow: hidden; opacity: 0.8;">${card.notes.substring(0, 100)}...</p>
                    <small style="font-style: italic; display: block; margin-top: 10px;">Location: ${card.location || 'N/A'}</small>
                    <small style="font-style: italic; display: block;">Tags: ${card.tags}</small>
                `;
                div.onclick = () => { switchView('editor'); loadEditor(card.id); };
                grid.appendChild(div);
            });
        }


        // --- EXPORT / IMPORT ---
        function saveJSON() {
            const blob = new Blob([JSON.stringify({cards: cards, metadata: scriptMetadata})], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'screenplay.json'; a.click();
        }

        function downloadFountain() {
            let f = "";
            
            // Title Card Metadata
            if (scriptMetadata.title || scriptMetadata.author) {
                f += `Title: ${scriptMetadata.title}\n`;
                if(scriptMetadata.author) f += `Author: ${scriptMetadata.author}\n\n`;
                f += "\n\n";
            }
            
            // Opening Transitions
            scriptMetadata.transitions.forEach(t => f += `${t}\n\n`);

            // Scene Content
            cards.forEach(c => {
                f += c.header.toUpperCase() + "\n\n";
                
                if(c.notes) f += c.notes + "\n\n";
                
                if (c.header.toUpperCase().startsWith('MONTAGE')) {
                    c.montage.forEach(item => {
                        f += `-- ${item}\n`;
                    });
                    f += "\n";
                } else {
                    c.sequence.forEach(s => {
                        if (s.type === 'Character') {
                            f += s.content.toUpperCase();
                            
                            // NEW: Build parenthetical content from structured fields
                            const inlineElements = [];
                            if (s.context) inlineElements.push(s.context);
                            if (s.contd) inlineElements.push("CONT'D");
                            
                            // Parenthetical action remains separate below the name line in the rendering process, 
                            // but in Fountain format, V.O. and CONT'D must be included here in one set of parentheses.
                            const styleContent = [];
                            if (s.parenthetical) styleContent.push(s.parenthetical);
                            
                            const allParentheticals = [...inlineElements, ...styleContent].join(', ');
                            
                            const finalTag = allParentheticals ? ` (${allParentheticals})` : '';
                            f += finalTag + "\n" + s.text + "\n\n";

                        } else if (s.type === 'Action') {
                            const styleUpper = (s.style || '').toUpperCase();
                            
                            if (styleUpper === 'TITLE CARD:' || styleUpper === 'INTERTITLE:') {
                                const prefix = styleUpper.startsWith('INTERTITLE') ? 'INTERTITLE' : 'TITLE CARD';
                                f += `${prefix}: ${s.content}\n\n`; 
                            } else {
                                f += s.content + "\n\n";
                            }
                        }
                    });
                }
                
                const finalTags = c.tags.split(',').filter(t => t.trim().toUpperCase().includes('FADE OUT') || t.trim().toUpperCase().includes('CUT TO') || t.trim().toUpperCase().includes('DISSOLVE TO'));
                finalTags.forEach(t => f += `${t.trim().toUpperCase()}.
        \n\n`);
            });
            const blob = new Blob([f], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'screenplay.fountain'; a.click();
        }

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const content = e.target.result;
                let successMessage = "";
                
                if(file.name.endsWith('.json')) {
                    try { 
                        const loadedData = JSON.parse(content);
                        if (Array.isArray(loadedData)) { 
                            cards = loadedData;
                        } else if (loadedData.cards) { 
                            cards = loadedData.cards;
                            scriptMetadata = loadedData.metadata || scriptMetadata; 
                        }
                        
                        // Data migration logic for JSON load
                        cards.forEach(card => {
                            if (card.dialog && !card.sequence) {
                                card.sequence = card.dialog.map(d => ({ type: 'Character', content: d.character, text: d.text, context: '', contd: false, parenthetical: '' }));
                                delete card.dialog;
                            }
                            card.sequence.forEach(s => {
                                if (s.type === 'Character') migrateDialogueFields(s);
                            });
                            if (!card.location) { card.location = extractLocation(card.header); }
                        });
                        successMessage = "JSON Loaded! Total Scenes: " + cards.length;
                    } catch(e) { 
                        alert("Invalid JSON file format. Check console for details."); 
                        console.error(e);
                        return; 
                    }
                } else {
                    parseFountainImport(content); 
                    successMessage = "Imported " + cards.length + " scenes from text/fountain.";
                }
                
                // 1. Save data
                saveData(); 
                
                // 2. Log success
                if (successMessage) { console.log(successMessage); }

                // 3. Load the first card and switch view
                if (cards.length > 0) {
                    switchView('editor'); 
                    activeCardId = cards[0].id;
                    loadEditor(cards[0].id);
                } else {
                    activeCardId = null;
                    loadEditor(null);
                }
                
                // 4. Clear input element
                input.value = ''; 
            };
            
            reader.readAsText(file);
        }

        function parseFountainImport(text) {
            cards = [];
            scriptMetadata = { title: 'UNTITLED SCREENPLAY', author: '', transitions: [] }; 
            const lines = text.split(/\r?\n/);
            let currentCard = null;
            let isTitlePage = true;
            let actionBuffer = []; 
            
            const headerRegex = /^(INT\.|EXT\.|EST\.|I\/E|INT\/EXT|MONTAGE)/i; 
            const transitionRegex = /^(FADE IN|FADE OUT|CUT TO|DISSOLVE TO|SMASH CUT TO)/i;
            const characterLineRegex = /^([A-Z0-9\s,.'"-]+)(\s+\(.+\))*\s*$/; 
            const parentheticalRegex = /\(([^)]+)\)/g;

            const flushActionBuffer = (isSceneStart) => {
                if (!currentCard || actionBuffer.length === 0) return;
                if (currentCard.sequence && currentCard.sequence.length === 0 && !isSceneStart) {
                    currentCard.notes += (currentCard.notes ? '\n' : '') + actionBuffer.join('\n');
                } else {
                    currentCard.sequence.push({ type: 'Action', content: actionBuffer.join('\n'), style: '' }); 
                }
                actionBuffer = [];
            };

            const isLikelyAction = (line) => {
                const trim = line.trim();
                if (trim.length > 0 && /[A-Z]/.test(trim[0]) && /[a-z]/.test(trim[1])) { return true; }
                return false;
            };

            lines.forEach(line => {
                const trim = line.trim();
                if(!trim) { flushActionBuffer(); return; } 

                if (isTitlePage) {
                    if (headerRegex.test(trim) || trim.startsWith('.')) { isTitlePage = false; } 
                    else if (trim.includes(':') && trim.length < 50) {
                        const parts = trim.split(':');
                        const key = parts[0].trim().toLowerCase();
                        const value = parts.slice(1).join(':').trim();
                        if (key === 'title') scriptMetadata.title = value;
                        else if (key === 'author') scriptMetadata.author = value;
                        return;
                    }
                }
                
                if(headerRegex.test(trim) || trim.startsWith('.')) {
                    flushActionBuffer(true); 
                    const headerText = trim.replace(/^\./, '').trim();
                    const locationText = extractLocation(headerText);
                    currentCard = { id: Date.now() + Math.random(), header: headerText, location: locationText, chars:'', props:'', notes:'', tags:'', sequence:[], montage:[] }; 
                    cards.push(currentCard);
                    actionBuffer = []; 
                } 
                
                else if (transitionRegex.test(trim) && (cards.length === 0 || !currentCard)) {
                    scriptMetadata.transitions.push(trim);
                }
                else if (transitionRegex.test(trim) && currentCard) {
                    currentCard.tags += (currentCard.tags ? ', ' : '') + trim.replace(/\.$/, '');
                } 
                
                else if (currentCard) {
                    const isMontageBlock = currentCard.header.toUpperCase().startsWith('MONTAGE');
                    const charMatch = trim.match(characterLineRegex); 
                    let lastItem = currentCard.sequence[currentCard.sequence.length - 1];

                    if(charMatch && !isMontageBlock) {
                        flushActionBuffer(); 
                        
                        let context = '';
                        let contd = false;
                        let parentheticals = [];
                        let charLineWithoutParentheticals = trim;
                        
                        let match;
                        const parentheticalLineRegex = /\(([^)]+)\)/g; 
                        while ((match = parentheticalLineRegex.exec(trim)) !== null) {
                            const content = match[1].trim().toUpperCase();
                            
                            // Dedicated Tag Detection
                            if (content === 'V.O.') context = 'V.O.';
                            else if (content === 'O.S.') context = 'O.S.';
                            else if (content === 'CONT\'D') contd = true;
                            else if (content.length > 0) parentheticals.push(match[1].trim()); // Store original case for parentheticals

                            // Remove the matched block to clean the name line
                            charLineWithoutParentheticals = charLineWithoutParentheticals.replace(match[0], '').trim();
                        }

                        const characterName = charLineWithoutParentheticals.toUpperCase().trim(); 
                        
                        currentCard.sequence.push({ 
                            type: 'Character', 
                            content: characterName, 
                            context: context,
                            contd: contd,
                            parenthetical: parentheticals.join(', '), 
                            text: '' 
                        });
                        lastItem = currentCard.sequence[currentCard.sequence.length - 1]; 
                    } 
                    
                    else if (trim.toUpperCase().startsWith('TITLE CARD:') || trim.toUpperCase().startsWith('INTERTITLE:')) {
                        flushActionBuffer(); 
                        const prefix = trim.toUpperCase().startsWith('TITLE CARD:') ? 'TITLE CARD' : 'INTERTITLE';
                        const content = trim.substring(trim.indexOf(':') + 1).trim();
                        currentCard.sequence.push({ type: 'Action', content: content, style: prefix });
                    }

                    else if (isMontageBlock && trim.startsWith('--')) {
                        currentCard.montage.push(trim.substring(2).trim());
                    }
                    
                    // Parenthetical on a subsequent line (now strictly treated as parenthetical direction)
                    else if (trim.startsWith('(') && trim.endsWith(')')) {
                        if (lastItem && lastItem.type === 'Character' && !lastItem.text) {
                            const cleanParenthetical = trim.replace(/[()]/g, '').trim();
                            lastItem.parenthetical += (lastItem.parenthetical ? ', ' : '') + cleanParenthetical; 
                        } else {
                            actionBuffer.push(trim);
                        }
                    } 
                    
                    else if (lastItem && lastItem.type === 'Character') {
                        if (lastItem.text && isLikelyAction(trim)) {
                            actionBuffer.push(trim);
                            flushActionBuffer(); 
                        } else {
                            lastItem.text += (lastItem.text ? '\n' : '') + trim; 
                        }
                    }
                    else {
                        actionBuffer.push(trim);
                    }
                }
            });

            flushActionBuffer();

            cards.forEach(card => {
                const charSet = new Set();
                if (card.sequence) {
                    card.sequence.forEach(s => {
                        if (s.type === 'Character' && s.content) {
                            charSet.add(s.content.trim());
                        }
                    });
                }
                card.chars = Array.from(charSet).join(', ');
            });

            if(cards.length === 0) console.log("No scenes found.");
        }

        // --- STATS & SCRIPT (FINAL VERSION) ---
        function generateScript() {
            let html = '';
            
            // Title Page
            html += `<h1 style="text-align: center; margin-top: 200px; font-size: 36pt;">${scriptMetadata.title || 'UNTITLED SCREENPLAY'}</h1>`;
            if (scriptMetadata.author) {
                html += `<p style="text-align: center; margin-top: 100px;">Written by<br><b>${scriptMetadata.author}</b></p><div style="page-break-after: always;"></div>`;
            } else {
                html += `<div style="page-break-after: always;"></div>`;
            }
            
            // Opening Transitions
            scriptMetadata.transitions.forEach(t => {
                html += `<div class="sc-header" style="text-align: right; text-decoration: none;">${t}</div>`;
            });
            
            // Content
            cards.forEach(c => {
                html += `<div class="sc-header">${c.header}</div>`;

                if(c.notes) html += `<div class="sc-action">${c.notes}</div>`;

                if (c.header.toUpperCase().startsWith('MONTAGE')) {
                    if (c.montage && c.montage.length > 0) {
                        html += '<ul style="list-style-type: none; margin-left: 0; padding-left: 20px;">';
                        c.montage.forEach(item => {
                            html += `<li class="sc-action" style="text-indent: -20px; margin-bottom: 0.5em;">-- ${item}</li>`;
                        });
                        html += '</ul>';
                    }
                } else {
                    c.sequence.forEach(s => {
                        if (s.type === 'Character') {
                            // NEW: Build inline and parenthetical content from structured fields
                            const inlineElements = []; 
                            const standardParenthetical = [];

                            if (s.context) {
                                // V.O. / O.S. are inline elements
                                inlineElements.push(s.context);
                            } 
                            
                            // Get all the parenthetical content, separated by comma
                            const rawParenthetical = s.parenthetical ? s.parenthetical.split(',').map(p => p.trim()) : [];

                            // Check for CONT'D first, as it must be last in the inline tag list
                            if (s.contd) {
                                inlineElements.push("CONT'D");
                            }

                            // Any remaining text goes into the standard parenthetical block
                            rawParenthetical.forEach(p => {
                                if (p.length > 0) {
                                    standardParenthetical.push(`(${p})`);
                                }
                            });


                            // --- Character Name Line Assembly (Centered via Flex) ---
                            html += `<div class="sc-character-block">`;
                            html += `<span class="sc-character">${s.content}</span>`;
                            
                            // Join inline elements (V.O., O.S., CONT'D) and render with parentheses
                            if (inlineElements.length > 0) {
                                const renderedInline = inlineElements.map(p => `(${p})`).join(' ');
                                html += `<span class="sc-parenthetical-inline">${renderedInline}</span>`;
                            }
                            html += `</div>`; 

                            // --- Standard Parenthetical Line Assembly (Below Name) ---
                            if (standardParenthetical.length > 0) {
                                html += `<div class="sc-parenthetical-line">${standardParenthetical.join(' ')}</div>`;
                            }
                            
                            // --- Dialogue Block ---
                            html += `<div class="sc-dialog">${s.text}</div>`;
                        } else if (s.type === 'Action') {
                            const styleUpper = (s.style || '').toUpperCase();
                            if (styleUpper === 'TITLE CARD' || styleUpper === 'INTERTITLE') {
                                html += `<div class="sc-intertitle">${s.content}</div>`;
                            } else {
                                html += `<div class="sc-action-inline">${s.content}</div>`;
                            }
                        }
                    });
                }
                
                const finalTags = c.tags.split(',').filter(t => t.trim().toUpperCase().includes('FADE OUT') || t.trim().toUpperCase().includes('CUT TO') || t.trim().toUpperCase().includes('DISSOLVE TO'));
                finalTags.forEach(t => html += `<div class="sc-header" style="text-align: right; text-decoration: none; margin-top: 2em;">${t.trim().toUpperCase()}.</div>`);

                html += `<div style="page-break-after: always;"></div>`;
            });
            document.getElementById('script-content').innerHTML = html;
        }

        function showStats() {
            let intC=0, extC=0, dayC=0, nightC=0;
            cards.forEach(c => {
                const h = c.header.toUpperCase();
                if(h.includes('INT')) intC++; if(h.includes('EXT')) extC++;
                if(h.includes('DAY')) dayC++; if(h.includes('NIGHT')) nightC++;
            });
            const tot = cards.length || 1; 
            document.getElementById('stats-content').innerHTML = `
                <div class="stat-row"><div>Interior: ${intC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${(intC/tot)*100}%"></div></div></div>
                <div class="stat-row"><div>Exterior: ${extC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${(extC/tot)*100}%"></div></div></div>
                <hr>
                <div class="stat-row"><div>Day: ${dayC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="background:#f1c40f;width:${(dayC/tot)*100}%"></div></div></div>
                <div class="stat-row"><div>Night: ${nightC}</div><div class="stat-bar-bg"><div class="stat-bar-fill" style="background:#8e44ad;width:${(nightC/tot)*100}%"></div></div></div>`;
            document.getElementById('stats-modal').style.display = 'flex';
        }
        function handleSearch(val) { currentSearchTerm = val.toLowerCase(); renderList(); }
    </script>
</body>
</html>